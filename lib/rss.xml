<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[主仓库]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>主仓库</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Sun, 13 Oct 2024 06:39:38 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Sun, 13 Oct 2024 06:39:11 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[用于大规模键值存储的 LSM 树托管存储]]></title><description><![CDATA[ 
 <br><br>Hong Jiang University of Texas at Arlington Arlington, USA <a data-tooltip-position="top" aria-label="mailto:hong.jiang@uta.edu" rel="noopener" class="external-link" href="mailto:hong.jiang@uta.edu" target="_blank">hong.jiang@uta.edu</a><br>Lei Tian Tintri Mountain View, USA <a data-tooltip-position="top" aria-label="mailto:leitian.hust@gmail.com" rel="noopener" class="external-link" href="mailto:leitian.hust@gmail.com" target="_blank">leitian.hust@gmail.com</a><br>Fei Mei Qiang Cao* KLISS, WNLO, Huazhong University of Sci. and Tech. Wuhan, China {meifei, caoqiang}@hust.edu.cn<br><br><br>LSM 树、键值存储、文件系统性能、应用程序托管存储<br><br>用于大规模键值存储的托管存储。在 SoCC 17 会议记录中，美国加利福尼亚州圣克拉拉，9 月 24 日至 27 日，201715页 <a rel="noopener" class="external-link" href="https://doi.org/10.1145/3127479.3127486" target="_blank">https://doi.org/10.1145/3127479.3127486</a><br>键值存储越来越多地采用 LSM 树作为后端存储中的支持数据结构，并通过文件系统持久化其集群数据。文件系统不仅需要提供文件/目录抽象来组织数据，而且还要保留 LSM 树的关键优势，即物理设备上的顺序和聚合 I/O 模式。不幸的是，我们深入的实验分析表明，从数据布局和 I/O 处理的角度来看，LSM 树的一些好处可以被底层文件级索引完全抵消。因此，LSM 树的写入性能保持在远低于存储设备提供的顺序带宽所承诺的水平。在本文中，我们解决了这个问题并提出了 LDS，这是一种基于 LSM 树的直接存储系统，它通过利用 LSM 树结构的写时复制特性来管理存储空间并提供简化的一致性控制，从而充分利用 LSM 树的好处。在 LDS 上运行 LSM 树作为比较的基线，<br>
<br><br>日志结构合并树（LSM 树）已应用于大规模键值存储的本地和分布式环境，例如 LevelDB [19]、RocksDB [16]、HBase [66]、BigTable [7]、Cassandra [32]、PNUTS [11]、InfluxDB [23] 等，因为 LSM 树能够缓冲内存中的随机写入，然后对持久存储执行顺序写入，这是硬盘驱动器和固态设备的最佳预期访问模式 [22， 28, 43, 60].为了从 LSM 树的这些潜在优势中受益，其他传统上在 B 树中组织数据的流行数据库存储后端系统也开始在其新版本中使用 LSM 树，例如 MongoDB [13] 和 SQLite4 [61]。理想情况下，LSM 树希望将其数据存储到 storage<br>我们分别在三个具有 HDD 和 SSD 的代表性文件系统（EXT4、F2FS、BTRFS）上评估 LSM 树，以研究 LSM 树的性能潜力。评估结果表明，通过采用LDS 的 LSM 树友好数据布局，可以将 LSM 树的写入吞吐量从 from&nbsp;1.8X1.8X&nbsp;提高到&nbsp;3X3X&nbsp;HDD 上，从 1.3 倍提高到&nbsp;2.0×2.0×&nbsp;SSD 上的 SSD 上的<br><br>信息系统 开槽页;分层存储管理space 的 SPACE，但管理存储的文件系统可以通过文件系统索引来防止这种情况发生，如图 1 中所示的示例所示。通常文件系统将文件索引以文件元数据（即 inode）和资源分配映射（即块位图）的形式存储，以分别定位文件/目录数据块和寻找空闲块来存储要写入的数据。一方面，维护这些索引块会产生更多的非顺序 I/O，这会损害 HDD 和 SSD 的性能 [22， 28， 35， 43， 46， 60]。此外，所有这些索引块必须与数据块同步更新，以实现严格的数据一致性，这需要大量的额外工作来执行 [8， 9， 18， 21， 31， 51]。为了解决这些问题并充分利用<br>LSM 树，我们介绍了 LDS，这是一种 LSM 树意识的键值存储系统，它将 LSM 树数据直接映射到块存储空间上，无需额外索构的写时复制特性来管理数据一致性，以避免与引即可保留预期的顺序写入访问模式，并通过利用固有的索引机制和 LSM 树结一致性执行相关的开销因此， LDS 完全消除了复杂且<br><br><img src="读书笔记\曹老师2019年论文\assets\c794693ecb2673dc13277a64a5570d9d_md5.png"><br>图 1：LSM 树中预期的顺序模式如何被块存储上的文件系统分解的示例。请注意，inode 和分配映射是由不同的文件系统放置和更新的<br>昂贵的文件级索引操作，并大大减少了 I/O 的数量，并强烈保留了磁盘写入顺序性。LDS 的这些优势适用于 HDD 和 SSD。我们基于 LevelDB 实现一个 LDS 原型，以<br>与通过三种具有不同数据布局和 I/O 处理特性的代表性文件系统存储 LSM 树相比，评估直接存储 LSM 树的好处，即 ext4（就地更新）[40]、f2fs（基于日志，无需漫游树更新）[33] 和 btrfs（Btree 结构化和写入时复制）[55]。实验结果表明， LDS 在检查的所有工作负载下始终如一地显著提高写入性能。在 HDD 上。写入吞吐量至少提高了&nbsp;1.8×1.8×&nbsp;，最高可达&nbsp;3X3X&nbsp;。在 SSD 上，写入吞吐量至少提高了&nbsp;1.3×1.3×&nbsp;X X ，并且由于&nbsp;2.5×.2.5×.&nbsp;索引 LSM 树数据的快捷方式，读取性能也受益于 LDS 设计。本文的其余部分组织如下。在第 2 节中<br>我们提供了必要的背景和对文件系统上运行的 LSM 树的深入分析，以激励我们的 LDS 研究。LDS 的设计和实施在第 3 节中有详细说明。相关工作在第 5 节中介绍。最后，我们在第 6 节中结束我们的工作。<br><br><br>一个标准的 LSM 树由一系列容量呈指数级增长的组件&nbsp;C0C0​&nbsp;C1,…,CKC1​,…,CK​&nbsp;组成 [46]，其中&nbsp;C0C0​&nbsp;驻留在内存中，而所有其他组件都驻留在磁盘上，并且组件中的所有键都保持排序以便快速检索。每次数据&nbsp;CxCx&nbsp;量达到其容量限制时，组件的数据都会滚动合并到&nbsp;Cx+1Cx+1​&nbsp;为了分摊合并成本，最先进的 LSM 树<br>基于键值存储将每个磁盘上的组件拆分为 chunk [16， 19]，并且仅在组件大小达到限制时部分合并一个组件（一个或多个 chunk），该函数称为 compaction1。具体来说，对&nbsp;CxCx​<br>将以循环方式选择目标块 [19]，并将其合并到&nbsp;Cx+1Cx+1​&nbsp;中。与目标 chunk&nbsp;重叠的所有 chunk&nbsp;Cx+1Cx+1​&nbsp;都将被读出以参与合并排序过程。压缩后，将从合并生成的新数据块写入&nbsp;Cx+1Cx+1​&nbsp;，并删除参与合并的过时数据块。从 LSM 树的角度来看，chunk 写入操作可以看作是写时复制过程：新 chunk 中每个键值对的副本都存在于过时的 chunk 中。换句话说，可以恢复和重做块的中断写入操作。因为在所有新 chunk 都被安全持久化之前，不能删除原始 chunk。除了就地写入块之外，LSM 树还会生成预写日志到磁盘备份，以使组件&nbsp;C0C0​&nbsp;在崩溃时可恢复让我们以 LevelDB，一个广泛使用的 LSM 树键值<br>store 基于上面介绍的部分合并，作为一个具体示例。图 2 演示了 LevelDB 的结构，其中&nbsp;C0C0​&nbsp;由两个排序的跳过列表（MemTable 和 ImmTable）组成，每个磁盘组件称为一个级别（&nbsp;L0∼L3L0​∼L3​&nbsp;图中为），其中包含多个块（排序字符串表，或 SST）。SST 包括一个排序的键值对正文和一个尾部，该尾部将读取请求索引到正文。解码尾部总是从其最后一个字节（LevelDB 术语中的页脚）开始写入请求首先附加到备份日志，然后插入到 MemTable，如果其大小达到其容量限制，该 MemTable 将被标记为不可变 （ImmTable）。压缩&nbsp;C0C0​&nbsp;将 ImmTable 作为&nbsp;L0L0​&nbsp;块转储到磁盘上，而磁盘上组件&nbsp;Lrl​&nbsp;上的压缩会将其 SST 之一合并到&nbsp;.&nbsp;Ln+1​&nbsp;维护一个单独的结构来跟踪所有 SST 的元数据，称为 LSM 索引（即版本），由 MANIFEST 支持。每个 SST 都有一个唯一的 ID，该 ID 与其元数据一起记录在 MANIFEST 中。对关卡结构进行更改的压缩必须更新 MANIFEST，这也是以日志记录方式实现的，称为 version edit 或 △version。<br><br>通常，基于 LSM 树的本地键值存储（如 LevelDB）通过文件系统将数据持久化到存储中，在本文中称为 LSM-on-FS。在 LSM-on-FS 实现中，所有数据（例如，块、日志等）都以文件的形式存储。直观地说，文件系统应该使 LSM 树数据存储在大型顺序 I/O 中，这对于 HDD 和 SDD 等低级存储设备来说是一个理想的属性。不幸的是，这样的预期是巨大的。由于需要访问文件系统索引（FS 索引），顺序 I/O 实际上被分解为非顺序的小 I/O，如下所述。通常，FS 索引包括文件元数据（例如inode）<br>和资源分配映射（例如 bitmap），它们都存储在固定大小（例如 4KB）的文件系统块中<br><img src="读书笔记\曹老师2019年论文\assets\75e3a9552495f464139043818d995b59_md5.png"><br>图 2：LSM 树的 LevelDB 实现。inmemory 组件&nbsp;C0C0​&nbsp;，由两个排序的 skiplist（MemTable 和 ImmTable）以及每个 on-disk component&nbsp;′C1′′C1′​&nbsp;C2C2​&nbsp;等组成。是 level&nbsp;(L0(L0​&nbsp;L1L1​&nbsp;等）。在整个运行时中，有三种类型的磁盘写入，如 fgure 所示：用于备份内存表的预写日志（步骤 1）;在压缩中写入新生成的块 （SST）（步骤 4）;并在压缩完成后更新 LSM 索引（步骤 5）。<br>作为文件数据的组成部分。因此，对 LSM 块或 LSM 索引的更新通过非顺序的小写入来更新 FS 索引，从而导致不同程度的 I/O 放大，即 I/O 的数量和强度增加，这些 I/O 通常很小且不连续，具体取决于给定文件系统的性质。首先，对于就地更新文件系统（如 ext4），使用<br>文件的元数据通常被积极地存储在一个地方，而资源分配映射存储在另一个地方，而用户数据存储在有足够可用空间的其他地方，无论在 ext4 中的组“块组”内或之外）。写入文件的数据块不可避免地会导致更新 FS 索引的 I/O。崩溃中的失败写入会导致文件系统处于不一致的状态 [53]，从而导致空间泄漏或文件损坏。为了保持数据一致性，就地更新文件系统通常使用日志来获取 inode 和 bitmap 的原子更新，这会带来额外的开销。也就是说，编写日志成为通常的 FS 索引更新不可或缺的一部分，并且是通常的 FS 索引更新的补充。因此，我们也将日志视为此类文件系统的 FS 索引。由于用户数据块和索引块存储在不同的地方，就地更新的放大 I/O 通常是对存储设备的随机访问其次，对于基于日志的文件系统 [56]，一个就地更新，尽管对 FS 索引的更新可以与用户数据相邻，但它必须更新从根 inode 到用户数据以及分配映射的整个元数据路径，这种现象称为 wanderingtree 更新 [33， 55， 56]。此外，必须采取措施回收就地更新文件系统的死数据块，这一过程称为垃圾回收 （GC）。如何实现高效的 GC 对于实际的日志文件系统至关重要，尤其是在压缩过程中产生大量垃圾的 LSM 树环境中。我们已经在 NILFS2 [30] 上运行 LSM 树进行了实验，NILFS2 [30] 是Linux 中，发现在写入的数据量仅为文件系统卷的十分之一后，文件系统会停止工作，因为没有剩余空间。F2fs [33] 是一种实用的日志结构文件系统，它通过为元数据块引入节点地址表 （NAT） 并以就地更新方式存储资源分配映射来解决游荡树更新问题，但代价是失去了日志记录功能的好处并导致更多的随机 I/O。日志文件系统的一个问题是，集群用户数据（例如 LSM 树日志）可以在存储空间中碎片化 [70]。第三种类型的文件系统是写入时复制 （CoW）<br>文件系统，另一个就地更新的实例，例如 btrfs [55]，它也以浮动方式更新索引，只是它们不保证更新在物理上是连续的。在这两种类型的 out-of-place-update 文件系统中，如FS 索引在每次更新中都会写入新位置，必须定期更新确定位置的锚点以记录 FS 索引的最新位置，以免丢失对更新数据的跟踪。对锚点的每次更新都代表文件系统的新版本。如果成功更新文件数据但未检查版本，则如果发生崩溃，则可能导致实际的文件更新失败。因此，我们也将锚点视为此类文件系统的 FS 索引的组成部分。如上一小节所述，LSM 树具有它自己的索引来定位和描述数据块。在文件系统上运行时，LSM 索引和 LSM 块都由底层文件系统组织成文件。对 LSM 树块的单次更新实际上需要多个 pbysical udaseborit I lse OSthefolowingt wotyes （I） I/O for a 4MB chunk）;（2） 更新 FS 索引的 FS 块（至少 2 个 I/O，具体取决于文件系统组织）。在更新 LSM 索引时，将重复相同的过程，例如：（1） 更新 LSM 索引的 FS 块;（2） FS 索引的 FS 块更新。图 3 分别说明了 LSM 树通过三个代表性文件系统和 LDS 的写入模式。它表明 I/O 的数量显著放大，因为 LSM 树中预期的大型顺序写入 I/O 实际上通过文件系统在存储设备上转换为大量小型且可能非顺序的写入 I/O。为了提供更多见解，图 4a 显示了<br>当 LSM 树通过三个代表性文件系统运行时，总 I/O 的分数实际上是 FS 索引 I/O。我们还在图 4b 中显示了在原始 HDD 和 SSD 设备上持久保存不同大小的请求的 I/O 延迟。在图 4a 的 oun 实验中，我们通过分析在禁用备份日志的情况下顺序写入 LevelDB 的块跟踪结果来识别 FS 索引 I/O，以便仅持久更新块文件和 MANIFEST 文件。对于图 4b，每个结果是通过按顺序向原始设备发送一系列 write-fsync 请求对 10 秒来获得的，并使用请求的平均响应时间<br><br><img src="读书笔记\曹老师2019年论文\assets\086701fda35a7ff44e88bc56ed71ac6c_md5.png"><br>图 3：图 a、b 和 c 显示了 LSM 树通过三个代表性文件系统的写入模式，其中大写入是对 LSM 块的更新，而小写入是对 FS 索引和 LSM 索引的更新。图 d 显示 FS 索引写入被 LDS 完全消除，留下 LSM 索引写入。此图的实验是在 sequential workloads 下禁用备份日志的情况下运行的。<br>由于两级索引（LSM 索引和 FS 索引）导致的 I/O 这种差异不仅对 LSM 树的性能产生不利影响，而且还会损害底层存储设备（例如 SSD）在压力大的 LSM 树环境中的性能和耐用性文件系统的好处之一是它对对象的支持<br><img src="读书笔记\曹老师2019年论文\assets\2afecc8cdef7da02a715c0651dd9acda_md5.png"><br>图 4：（a） 通过三种代表性类型的文件系统存储 LSM 树时的 I/O 分布。（b）&nbsp;I/0I/0&nbsp;在 HDD 和 SSD 上持久保存不同大小的请求的延迟。<br>（文件），这种抽象使数据库存储能够提供它想要的任何更高级别的对象 [62]。但是，随着键值存储的普及和 LSM 树的广泛部署，来自应用程序的统一数据对象从文件系统抽象中受益甚微。因此，有必要了解存储堆栈引起的开销，以便开发高性能和可靠的 LSM 树存储系统。在本文中，我们研究了不同文件系统在存储 LSM 树数据时的行为，并设计了一个使用 LSM 索引直接管理存储空间并保留 LSM 树所需属性的系统。鉴于键值存储一直充当关系数据库（如 MySQL）[65]、分布式存储（如 MongoDB）或旨在加速小写入的文件系统 [15， 25， 54] 的存储引擎，我们提出的 LSM 树直接管理存储 （LDS） 为存储系统的设计提供了新的机会，以实现性能和一致性维护的显着改进。 本文的其余部分将详细介绍<br>作为延迟测量。实验结果清楚地表明，文件系统诱导的 inder I/O 虽然体积小，但远远超过实际用户数据 I/O 的数量，并大大降低了 LSM 树应用程序的性能。虽然大型 SST 产生的 FS 索引开销较低，但它们有限制。<br>首先，考虑到键值对本应很小 [2， 45， 46， 69] 这一事实，较大的 ==SST ==总是会导致更大的索引数据，这会导致更长的搜索路径。相反，较小的 SST 可以很好地组织起来，以将索引数据放入一个存储块中，以实现高效搜索。其次，大型 SST 上的压缩需要预留足够的可用存储空间来容纳新的 SST [20]，并且需要很长时间才能完成合并过程，这可能会阻止更紧急的操作，从长远来看会导致性能抖动和降级 [17]。在本文中，我们重点介绍了 LevelDB 采用的 SST 设置（例如 2~4MB），并提供了一个高性能的存储系统，该系统利用 LSM 树结构来完全消除 FS 索引<br><br>LDS 的目的是消除额外的 FS 索引，并在 LSM 树数据与其物理位置之间执行直接映射。我们通过设计一个 LSM 树友好的磁盘布局，并明确地将日志存储与 chunk 存储分开来实现这一点。在本节中，我们首先介绍 LSM 树自定义磁盘布局，以及 LSM 树数据是如何分类的。然后我们描述了 LDS 中管理存储管理的原则。本节最后讨论了重要的实施问题<br><br>上述对文件系统上运行的 LSM 树的分析表明，LSM 树的预期顺序聚合写入 I/O 与生成的文件系统非顺序（随机）小型写入之间存在明显的脱节和差异<br><br><img src="读书笔记\曹老师2019年论文\assets\0016bfccfd30573c81a873ba3dcd33aa_md5.png"><br>图 5：LSM 树数据的 LDS 在磁盘上的布局<br><img src="读书笔记\曹老师2019年论文\assets\f87b5943ad93d3bb43c38ddd6e856385_md5.png"><br>Figure 6: Log object format.<br><br>LDS 的磁盘布局如图 5 所示。整个卷分为三个区域：版本日志区域、备份日志区域和插槽区域。插槽区域中的所有插槽具有相同的大小，并按它们到第一个插槽的偏移量（插槽 ID）按顺序编号。插槽可以包含一个 LSM 树块，该块也具有从偏移量派生的 ID（块 ID），因此 LDS 可以立即定位给定块的物理位置。这两个日志区域包含具有 Figure 6 所示合法格式的连续日志对象，其中 magic 和&nbsp;CRCCRC&nbsp;fields 用于确保日志对象的完整性，type 和&nbsp;SNSN&nbsp;（sequence number） 字段用于标识恢复中的活动日志对象（在 Section 3.3 中描述），size 字段表示有效负载包含多少字节。活动对象是在恢复中应考虑的对象。相反的是应该忽略的过时对象：版本日志包含两种主要类型的对象。(1)<br>基本版本 （BV） 包含生成基本版本时 LSM 树的完整描述：所有块的元数据等。数据块的元数据由数据块 ID、它所属的级别、数据块的最小和最大键组成。此外，LDS 会复制基本版本中的存储格式信息。（2） △ 版本 （△V） 描述了压缩的结果，例如，应该删除的过时 chunk 和应该添加的新 chunk。所有版本及其相应的基本版本都可以合并到新的基本版本，此过程称为 trim。备份日志主要包含 Write-Ahead-Log （WAL） 对象，这些对象为尚未持久化到磁盘结构中的内存中键值对（即图 2 中的 MemTable 和 ImmTable）提供备份。slot 区域存储 LSM 树块，每个<br>一个区块。如前所述，块由一个包含已排序键值对的 body 和一个 tail 部分组成，用于在正文中为请求的键编制索引。由于 LSM 树不能总是生成具有其托管槽确切长度的块，因此块的主体和尾部可能不会完全占据槽。一个小的填充区域用于使尾部与其槽边界右对齐，如图 7 所示，因此右对齐<br><img src="读书笔记\曹老师2019年论文\assets\6763d162069f4b0422e9ef79456c4bb8_md5.png"><br>图 7：Chunk 包。Padding 用于填充插槽左侧的 body 部分和 Tail 右侧的 tail 部分之间的间隙。<br>尾巴的末端可以立即找到 2.此存储解决方案不会导致存储空间中出现外部碎片，删除块会立即释放其托管槽以供重新分配。因此，LDS 不存在一般 CoW 系统的垃圾收集和碎片整理问题 [33， 55]。但是，slot 内的填充区域会导致内部碎片化，这将在 Section 3.4 中讨论。<br><br>一个完整的 LSM 树包括版本（LSM 树索引）、备份日志（内存中 LSM-trec 组件的磁盘备份）和 chunks（自索引键值组）。在本节中，我们将介绍如何保持这三个区域的写入一致性。版本表示备份状态的快照，<br>块组织。如果从关卡中删除任何数据块或将其插入到关卡中，则可以在将来更改组织。这只发生在压缩过程中。压缩完成后，应从版本中删除参与压缩的块的元数据，并将从压缩生成的块的元数据添加到版本中。回想一下，块从一个级别到另一个级别的微不足道的移动也被视为压缩操作，包括内存表转储。如果内存表被压缩到磁盘块，则备份日志中活动对象的起点将被重置。新的起点记录在表示此内存压缩的版本中。LSM 树不会就地更新版本，而是通过在版本日志中附加更改 （△version） 来提交更改 （△version），并将一组版本与基本版本合并以生成新的基本版本。只有成功提交的 △ 版本才能保证压缩结果在 LSM 树上。否则，压缩的任何结果都将被丢弃，就像什么都没发生一样。由于新 chunk 始终写入空闲插槽中，并且在提交 Aversion 之前不会被其他压缩看到，因此损坏的压缩对原始数据没有影响。对于内存压缩，由于备份日志的重置起点记录在 △ 版本中，因此 Aversion 失败只会取消该重置。换句话说，提交 Aversion （1） 会从版本中删除旧块，（2） 将新块添加到版本，以及 （3） 以原子方式重置备份日志的起点。<br><br><img src="读书笔记\曹老师2019年论文\assets\d926e0a66b683f833b7b9366d5fbb352_md5.png"><br>图 8：修剪以生成新的基本版本。这些版本与其基本版本共享相同的 SNvalue<br>插槽使用状态（已分配或可用）可以通过检查基本版本和 Aversion.重新启动时，恢复过程将在线构建一个位图，用于在执行修剪时跟踪插槽使用情况。我们将此位图称为 online-map，以区别于单独存储在持久化存储中的传统位图，必须将其视为一致性控制。在运行时分配槽会立即在 online-map 中 FIF 其状态（从 free 到 allocated），以防止再次分配它们。但是，如果发生崩溃，只有成功提交的 △ 版本才会保持翻转结果。必须在提交 Aversion 后执行将插槽的状态从 allocated 翻转为 free 以删除 chunk;否则，数据可能会损坏，因为 LSM 树可能会恢复到已提交的先前版本，但已重新分配槽以存储错误的数据。例如，考虑到在 Aversion r 中分配并在 Aversion&nbsp;yy&nbsp;中释放的插槽，如果在提交 △version&nbsp;yy&nbsp;之前，该插槽在在线地图中的状态翻转为 free，则可能会在发生崩溃时分配该插槽来存储新的块。因此，在重新启动时，系统会将插槽恢复到 Aversion&nbsp;XLXL&nbsp;，但插槽存储了错误的数据。当崩溃发生时，在线映射中未释放的插槽永远不会导致空间泄漏，因为恢复中的 trim 过程将根据提交的版本构建在线映射如果压缩生成新的块，LDS 必须分配<br>free 插槽来持久化这些块。分配可以通过基于在线地图的任何方式实现。新的 chunk 将根据其分配的 slot 的偏移量分配一个 ID，这样从版本中记录的 chunk ID 中我们可以直接知道 chunk 的托管 slot。LDS 中的默认分配实现类似于 LFS 中的线程日志记录 [33， 56]，但以插槽作为主要单元。也就是说，LDS 在扫描在线地图以寻找空闲时段时总是朝一个方向前进，并在到达终点时绕行。如果一轮完整的扫描未能找到足够的空闲槽，则会报告“space full”状态，尽管联机映射是纯内存中数据结构<br>非常小的大小（例如，对于具有 4MB 插槽的 100GB 存储，只需要 3.2KB 内存），当空间接近满时，分配过程可能会变得效率低下，因为它需要在在线映射中扫描更多位才能找到空闲位。为了加快分配过程，LDS 还维护了一小部分将在不久的将来分配的空闲插槽，称为 partial-list。当 find_free 线程的大小低于阈值时，将在后台触发该线程，以将空闲插槽 ID 附加到部分列表。<br><br>日志是 LSM 树中的一个重要组成部分。除了支持内存表的备份日志外，版本还以日志记录方式更新（即 Aversion）。在本节中，我们将介绍 LDS 中的高效日志机制，以及如何从日志崩溃中恢复一致状态。<br>3.3.1严格附加和崩溃恢复。版本日志和备份日志都以循环方式使用，这是日志记录或日记的常见用法。通过文件系统存储的日志通常在追加操作后必须更新文件索引。对于采用日志的文件系统本身，例如，ext4 中的日志，在日志区域的开头设置一个超级块（journal super）[53]，并在之后更新以识别实时和过时的日志项。相比之下，LDS 仅使用一个物理追加操作来更新日志，而无需更新任何其他标识数据。LDS 通过使用 log 对象中的一些特殊字段（例如 type 和 SN，图 6）来识别活动对象来实现这一点。对于版本日志，最新的基本版本用作<br>分离活动对象和过时对象，如图 8 所示。每次执行 trim 过程时，都会保留基本版本。现在，我们假设 version 区域以 legal 对象开头，稍后我们将讨论如何识别日志是否回绕。在恢复过程中，LDS 会从头开始扫描版本日志区域中的所有对象，直到遇到垃圾（即格式非法或 SN 值小于最新扫描的 SN 值），并识别最新的 Base 版本（SN 值最大）及其所有具有相同 SN 值的后续版本，以恢复版本结构和在线地图。对于备份日志，如 Section 3.2 中所述，活动对象的起点可以从对应于最新内存压缩的 Aversion 中获得。恢复内存表是通过从起点扫描备份日志来实现的。<br>当版本日志和备份日志末尾的剩余空间不足以容纳所请求的对象时，版本日志和备份日志都会自动换行。为了使 wrapping 状态对恢复过程可识别，LDS 引入了两个特殊对象。如图 9 所示，一个在日志换行时附加到最后一个对象旁边，称为右侧的 urapping 对象 （WOR），另一个在日志换行时放置在日志区域的开头，称为左侧的包装对象 （WOL）。当日志回绕时，WOL 包括一个指向第一个活动对象的指针，而 WOR 只是一个边界标识符，通知恢复过程返回到日志区域的开头。在实践中，只有版本日志 WOL 生效，因为 LDS 总是从日志区域的开头扫描对象，并且只需要跟踪右端活动对象，而对于备份日志，只有 WOR 生效，因为 Aversion 已经指定了起点，但如果日志已经包装，它需要知道包装边界。然而，在扫描版本日志时，LDS 不会立即转到 WOL 指向的右侧部分，因为它们可能已经过时（通过修剪过程）。由于包装对象与右端对象具有相同的 SN<br><br>耐用。LDS 保证在收到同步请求时，操作系统缓存的插入将提交到备份日志中上述提交策略提出了一个问题，即如何<br>标识恢复中备份日志的起点，因为 Aversion 指向的起点对象可能尚未保留。为了解决此问题，LDS 还会在版本中记录 start point 对象的 SN。如果恢复过程发现起始点对象的 SN 与 △version 中记录的 SN 匹配，则直接忽略备份日志。<br><img src="读书笔记\曹老师2019年论文\assets\a58d48af663aed636c8c5460886af70c_md5.png"><br><br>当日志环绕时，LDS 通过查找 WOL 之后的基本版本来了解它们是否过时。如果 LDS 无法从左侧的合法对象中找到实时基础版本，则 LDS 会转向右侧部分：这意味着左侧的对象都是实时版本，并且它们的基本版本存在于右侧部分。由于日志区域通常不大，因此扫描<br>原木区域不会像人们想象的那么昂贵。例如，对于配置了 4MB LSM 树块的 100GB 存储，2MB 版本日志通过定期修剪就足够了，考虑到对象头开销，16MB 备份日志对于两个内存表（图 2）就足够了。即使在运行时没有修剪，就像在 LevelDB 中一样，累积的版本数据也不会超过 50MB，持续的随机写入会填满存储空间。此外。将物理上连续的数据块加载到内存是利用底层存储设备的高级顺序带宽的最佳方式。例如，商用 HDD 的顺序读取带宽为 150MB/s，只需 0.33 秒即可将 50MB 版本日志加载到内存中，并且在内存中执行扫描速度很快。我们在第 4.4 节中评估了恢复成本。<br>3.3.2提交策略。在 LDS 中，每个压缩结果（versio）都提交到版本日志中，以提供最新磁盘结构的一致状态，而 WriteAhead-Logs （WAL） 被提交到备份日志中，以便恢复内存中的键值对。崩溃前的未提交 Aversion 将使压缩过程已完成的所有工作无效，而延迟提交会阻止其他压缩操作对与此未提交 Aversion 相关的块进行操作。在 LevelDB 中，立即提交 Aversion：最近插入到备份的未提交 WAL<br>log 将导致 Insertions 丢失。但是，提交每个 WAL 的成本非常高，因为 I/O 延迟比内存操作长几个数量级。低延迟和字节可寻址的 NVM 技术很有希望用于 WAL 提交 [29]，但尚未得到广泛使用。因此，用户必须在性能和持久性之间做出自己的权衡。例如，一些应用程序频繁地进行 fsync 调用来提交最近的写入，以确保高持久性 [26， 47]，但代价是吞吐量下降，而其他应用程序可能会通过牺牲持久性来禁用备份日志或将累积日志刷新到操作系统缓存以实现高吞吐量 [37， 57]。LDS 继承了 LevelDB 策略，该策略默认将每个 WAL 推送到 OS 缓存。如果用户希望插入请求<br><br>块的主体部分和尾部部分之间的填充（图 7）会导致内部碎片化，从而导致 LDS 中的一些存储空间浪费。在压缩的 merge 排序中，merge 进程<br>并行遍历多个 chunk 并在新 chunk 的主体中对它们的键值对进行排序。新 chunk 的尾部会随着 body 的增加而更新。在检查了主体和尾部的大小后，将块打包。如果合并过程发现向 body 再添加一个键值对会导致 package 溢出 slot 大小，则不会添加此键值对，而是轮流执行打包。在这种情况下，可能会发生内部碎片，因为插槽有一些可用空间，但不足以用于合并过程的下一个键值对。这种碎片也存在于文件系统中，因为很难生成与文件级块大小（例如 4KB）完全一致的块文件。只要键值对的大小小于文件级块的大小，这是 LSM 树键值存储中的常见情况 [2， 45， 46， 69]，LDS 中的内部碎片就不会比文件系统中的更有害，但是，在合并排序结束时，<br>无论 last chunk 包含的数据多么少，都必须打包它。LDS 中的此类数据块称为具有可变大小的奇数数据块，关卡中存在的奇数数据块过多会导致严重的内部碎片。为了减少 odd chunk 引起的内部碎片，我们对每次 compaction 中 odd chunk 的处理逐级&nbsp;LL&nbsp;进行了小幅更改&nbsp;L+1L+1&nbsp;。奇数块不是放在 level&nbsp;L+1L+1&nbsp;中，而是保留在 level&nbsp;LL&nbsp;中，并且在未来的操作中有两种可能性。一种是它被 level&nbsp;L−1L−1&nbsp;的下一个压缩选择为重叠的 chunk。另一个是它附加到它的下一个相邻块，该块将参与 level&nbsp;LL&nbsp;的下一次压缩。在这两种情况下，奇数块都被同化和吸收。这样，每个级别最多有一个奇数块，而不管 store 的大小如何。由于奇数块不与关卡&nbsp;LL&nbsp;中的任何块重叠，因此&nbsp;L+1L+1&nbsp;将其放置在关卡&nbsp;LL&nbsp;中不会破坏树结构。另一种替代方法是优先选择奇数块作为压缩的受害者，而不是以循环方式选择<br><br><br>我们基于 LevelDB 1.18 实现了一个 LDS 原型来评估我们的设计。<br>第一个任务是管理存储空间，称为 I/O 层。我们使用 ioctl 获取存储分区的属性，并通过在版本日志中写入初始版本来启动空间。物理空间上的 I/O 操作由 open/write/mmap 系统调用实现。对于同步请求，调用 sync_file_range [42] 并设置了必要的标志？保证数据持久化虽然 LDS 可以掌控缓冲区管理工作，选择合适的 flush 机会，在不失去数据一致性的情况下实现更好的性能，比如在后台进程中启用并发合并和 flushing，但我们目前在原型中实现了这个功能，以与 LevelDB 中相同的方式工作， 从而提供公正的评估结果。一般来说，LDS 区分了 chunk、version log 和 backup log 三种类型的写入请求，并根据上述设计分别处理它们。总共编写了 456 行代码来实现 I/O 层。第二个任务是修改 LevelDB，使其可以在 LDS 的 I/O 层上运行，主要是 env 接口的新实现，总共编写了 32 行代码。<br><br>3.6.1 使用预先分配的文件空间。LDS 可以用作存储引擎，通过提供键值接口 （put/get/delete） 来管理低级存储设备。尽管如此，在文件系统预先分配的文件空间上运行 LDS 是很容易可行的。对于用户来说，使用预先分配的文件空间与使用原始设备完全相同，但 LDS 内部不能直接在预先分配的文件空间上使用sync_file_range，因为 sync_file_range 的使用限制以及文件系统对物理空间分配的潜在干扰一般来说，预先分配的分配的文件空间从 O 开始，并静态映射到 LDS。分配文件空间的文件系统维护文件空间与 inode 中的存储空间之间的映射。sync_file_range 仅确保文件空间范围内的数据同步到相应的存储空间 [42]，但不确保 inode 数据（映射信息）同步。如果文件系统就地更新 [40]，则在文件空间中写入和同步数据时，映射信息不会更改，并且在崩溃后检索同步数据没有问题。但是，如果文件系统不就地更新[33， 5]，则在其文件空间中写入和同步始终会导致数据被保存在新的存储位置，并且应更新 inode 中的映射数据以跟踪新位置。在这种情况下，如果映射数据未同步，则文件空间中的同步数据将在崩溃后丢失。因此，fsync/fdatasync 必须用于通知文件系统同步映射信息预先分配的文件空间中的备份日志需要专门针对就地更新文件系统处理。如 Section 3.3.2 中所述，备份日志的同步速度通常与 slot 或 version 数据的速度不同。但是，预先分配的文件空间上的 fsync 适用于整个文件空间，在用户选择延迟提交备份日志的情况下，会导致性能下降。一个实用的解决方案是为备份日志指定一个单独的分配文件空间。实际上，将备份日志单独存储在不同的存储空间中是提高日志记录效率的实用方法 [12]，本文不再进一步详细说明。<br>3.6.2 存储大小调整。LDS 适用于原始设备空间和文件系统分配空间，通过在版本中设置特殊字段来描述其管理的存储空间，可以根据用户扩展或缩小存储空间的需求灵活调整空间<br>扩展存储空间，即加入新设备或从文件系统请求更多空间，是通过重新构建在线地图来体现新空间的扩展槽来实现的。将生成一个新版本以包含已加入空间的信息。为了缩小存储空间，即删除设备或为文件系统返回一些空间，LDS 首先将缩小槽中的块复制到其他空闲槽，然后修剪版本并重新构建在线映射以排除缩小的槽。在修剪过程中。最初存储在 shrunk slot 中的 chunks 将根据其新的托管 slot 分配新的 ID。<br><br>本节介绍了恶魔 STON STS 的好处的实验结果<br><br>实验是在配备两个 Intel（R）Xeon（R） CPU E5-2683 v3 @ 2.00 GHz 处理器和 32GB RAM 的机器上进行的。操作系统为 64 位 Linux 4.4。使用的 HDD Seagate ST2000DM001 的容量为 1.8TB，顺序写入速度为 152MB/s，使用的 SSD Intel SSD DC S3520 系列 2.5 英寸的容量为 480GB，顺序写入速度为 360MB/s。请注意，HDD 在外柱面上的速度略快。我们的实验为每个系统选择从 800GB HDD 开始的分区，以最大限度地减少对单个实验的硬件影响。驱动器的写入缓存被禁用，以确保数据得到安全存储我们将 LDS 的性能与 LevelDB 的性能进行比较<br>（1.18） 运行在三个典型的文件系统上，ext4 （就地更新） [40]， f2fs （基于日志） [33] 和 btrfs （写时复制） [55] 所有文件系统都使用 noatime 选项挂载，以消除与我们的评估无关的潜在开销 在 LevelDB 中，块 （SST） 大小配置为 4MB LDS 中的版本日志和备份日志配置为<br><br>分别为 64MB 和 16MB，槽位大小为 4MB该配置不会触发版本日志上的 trim 过程，这是 LevelDB 中的做法。修剪过程的成本与恢复过程一起评估（第 4.4 节）。在所有实验中禁用 LevelDB 中的数据压缩<br><br>在本小节中，我们使用 LevelDB （db_bench） 中的默认基准测试来分别评估 LDS 和 LSM-on-FS 在顺序和随机工作负载下的插入性能。我们还评估了同步模式下的插入性能。平均键值对大小为 116 字节（即 16B 键，值范围为 1B 到 200B，分布均匀）<br>4.2.1 顺序工作负载。图 10 显示了顺序工作负载下的性能（以运行时间表示）与插入次数的函数关系。从图中我们可以看到，LDS 在 HDD 和 SSD 上的性能都最好。为了进一步分析结果，我们通过检查不同类型的操作 / 事件对运行时间的贡献，仔细研究图 11 中的时间成本。LSM 树<br><img src="读书笔记\曹老师2019年论文\assets\b9d799c0c72f55bdaca5a282c5adc5b5_md5.png"><br>图 10：顺序插入性能（越低越好）。<br>具有用于预写日志 （Log） 和 MemTable 插入 （Mem） 的前台线程 （Front），并在 MemTable 转换为 ImmTable 时触发后台线程 （Back） 进行压缩。如果后台线程没有及时完成该过程，则前台操作会减慢 （Wait）。在顺序工作负载下，压缩中没有合并排序，块写入仅发生在将 ImmTable 转储到&nbsp;L0L0​&nbsp;时。磁盘级别的压缩是一个简单的移动操作，它只更新 LSM 索引。在 HDD 上，LSM-on-FS 中的后台进程很慢<br>由于 LSM 的 FS 索引更新频繁<br><img src="读书笔记\曹老师2019年论文\assets\8e53fd82d1e3050d2c352624d3a754db_md5.png"><br>图 1l：顺序插入的运行时间细分。<br>chunk 和 LSM 索引，并且前台有等待时间。在 SSD 上，由于 fash 的低延迟，所有系统都可以快速完成后台处理，因此前台成本（主要是日志记录成本）主导了整体性能。然而，不同的文件系统会产生相应的日志请求开销，因为它们有自己的写入系统调用（从 LevelDB 的刷新转换而来）的处理机制，这些调用将 WAL 推送到操作系统缓存。例如，他们将检查是否有足够的空闲块用于写入，以保证未来的刷新不会失败 [68]。<br>4.2.2 随机工作负载。随机工作负载下的性能结果如图 12 所示，以运行时间作为插入次数的函数。随机插入会导致后台频繁的 Compaction 合并操作，并且需要很长时间来执行 Merge 排序和 chunk 写入。因此，前台进程大部分时间都在等待后台进程，而块写入效率最高的系统性能最好，如图 13 中随机插入的运行时成本分布所示。后台进程可能会阻止前台进程，因为 LSM 树的每个级别都有一个容量限制以及两个内存表，如 2.1 中介绍的那样。当内存表已满且空间&nbsp;L0L0​&nbsp;处于压力下时，前台进程必须减慢插入操作或等待后台压缩产生足够的空间在&nbsp;L0L0​&nbsp;4.2.3 同步插入中。<br>在默认设置下使用备份日志运行，即仅将每个预写日志刷新到 OS 缓冲区。但是，用户有时希望在插入请求成功返回后，他们发出的插入是持久的。在这种情况下，我们使用 LevelDB 提供的同步模式来评估性能。在同步模式下，插入吞吐量完全由备份日志的写入效率决定，无论工作负载是顺序的还是随机的。以插入操作延迟测量的插入效率如图 14 所示。对于同步模式下的插入请求，LDS 可以<br>实现相当于在原始存储设备上写入相同大小数据的效率（参见图 4b）。这是<br><br><img src="读书笔记\曹老师2019年论文\assets\b3b2f034bcbf0fe0cc94bd6029e7ff30_md5.png"><br>图 14：同步模式下的插入延迟。保证每个 WAL 都是持久的。<br><img src="读书笔记\曹老师2019年论文\assets\12191f4ba507070b53ec2980719a43d8_md5.png"><br>Figure 12: Random insertion performance (lower is better).<br><img src="读书笔记\曹老师2019年论文\assets\ccc5d72e20be61cf945f86a82a1fa490_md5.png"><br>图 13：随机插入的运行时间明细。<br>因为 LDS 在备份日志区域中只产生一个 I/O。在 LSM-on-FS 中，有几个 FS 索引块需要与备份文件更新一起更新，以保证请求在存储和文件系统中都持久存在。F2fs 通过实现前滚机制 [33] 针对小型同步请求进行了优化，该机制消除了许多 FS 索引更新，因此它的性能优于 ext4 和 btrfs。但是，f2fs 仍然需要为 FS 索引更新一个区块（即 f2fs 中的直接节点），这会导致比 LDS 更长的延迟。<br><br>我们加载 10 亿个固定大小（16B 键和 100B 值）的随机键值对来设置一个 100GB 的数据集来评估读取性能。可用的操作系统缓存限制为 1GB，以模拟&nbsp;100×100×&nbsp;X X 存储/内存配置。更大的存储系统可以具有更高的存储/内存配置比率 [63]。用于读取的并发线程数在 HDD 上设置为 4，在 SSD 上设置为 16。我们衡量<br>冷缓存和暖缓存中的吞吐量和读取放大率，如图 15 所示。对于键的读取请求，它会在查找<br>向上查找驻留在内存中的 LSM 索引。然后，不同的系统将 chunk ID 转换为 chunk 数据的磁盘位置。与 LSM-on-FS 必须读取 FS 索引（fle 元数据）才能定位 chunk 数据不同，LDS 可以直接从 LSM 索引中确定 chunk 位置。由于不同的系统以自己的方式组织存储空间和设计数据索引机制，它们会引起不同的读取放大，这不仅影响了缓存效率，还影响了读取性能。例如，ext4 将多个 inode 聚集在一个块中，而 f2fs 为每个节点对象专门分配一个块 [33]然而，有趣的是，btrfs 的性能特别低。对跟踪的进一步分析表明，btrfs 的读取流量明显高于其他 btrfs，如图 15c 所示。读取放大由平均 I/O 负责<br>已处理请求的 traffic 中。在冷缓存中，几乎所有请求都使用 I/O 进行处理，以将可能包含请求的键值数据的存储块加载到内存缓存中，因此存在很高的读取放大率。随着缓存的预热，由于缓存命中而避免了一小部分 I/O，从而降低了读取放大率。特别是，对于单个读请求，btrfs 会在冷缓存中产生 8 个 I/O，其中一半大于 512KB，无论是 I/O 的数量还是大小，都远高于其他系统。由于我们使用相同的 mmap 系统调用从底层存储中读取 chunk 数据，因此读取放大的差异只能由不同系统的内部数据布局引起。Mohan 等人也观察到 btrfs 的高读长扩增 [44]<br><br>在本小节中，我们将评估从磁盘版本日志中恢复内存中版本的成本。从备份日志中恢复内存表的过程与此类似，但无需扫描整个日志区域即可找到有效对象。我们对 LDS 的评估总是假设最坏的情况，也就是说，即使我们已经确定了所有活动对象，我们仍然扫描整个版本日志区域 （64MB）。只有在扫描完成后，我们才开始执行 TRIM。<br><br><img src="读书笔记\曹老师2019年论文\assets\713c1428cb5466c1af016abe6e4d4d5f_md5.png"><br>图 15：冷缓存和暖缓存的读取吞吐量和放大率。读取线程数在 HDD 上为 4，在 SSD 上为 16。第一个&nbsp;10×10×&nbsp;线程数请求将考虑冷缓存结果，而暖缓存的结果是在空闲缓存填满且吞吐量达到稳定状态后实现的。读取放大是通过请求的平均 IO 流量 （KB） 来衡量的。<br>LevelDB 恢复过程的总时间成本用于衡量恢复性能。在文件系统准备好后执行 LSM-onFS 的实验，并且不考虑挂载期间的文件系统一致性检查 [38]。我们使用 4.2 节中的随机工作负载，插入 100~10 亿个键值对，生成不同大小的版本数据（从 3MB 到 47MB）<br>data 和 2 秒，则恢复时间的差异归因于 I/O 成本。正如我们所知。日志结构的文件系统总是在块地址空间的 logging head 上为所有文件分配块。虽然版本文件（应用程序的逻辑日志）定期与 SST 文件写入混合附加，但它会被文件系统日志碎片化，这个问题类似于已知的 log-onlog 现象 [70]。因此，f2fs 所需的恢复时间明显长于 HDD 上的其他系统版本文件碎片化也可能发生在通用 CoW 文件系统 [50]（例如 btrfs）中。此外，如第 4.3 节所示，btrfs 具有很高的读取放大率，因此，在 HDD 和 SSD 上读取 btrfs 的版本文件都是一项昂贵的操作，当版本运行时，LDS 花费的时间比其他 LDS 略多。<br>sion 数据很小。这是因为在最坏的情况下，LDS 必须加载整个日志区域并执行彻底扫描以查找活动对象，而不管版本数据大小如何，这在 HDD 上需要 0.35 秒，在 SSD 上需要 0.18 秒的恒定时间。通过这个小的权衡，LDS 可以在运行时执行高效的日志更新<br><img src="读书笔记\曹老师2019年论文\assets\bbff9ffde404abc4bab1a896611e3deb_md5.png"><br><br>图 16：恢复时间与 ac 累积版本数据大小的函数关系。<br>在本小节中，我们比较了不同系统的空间利用率，以研究 LDS 中内部碎片化的影响。我们将利用率定义为系统可以在具有给定容量的存储设备上容纳的固定大小的键值对的数量。每个系统的实验都是通过使用随机工作负载用 116 字节的键值对（16B 键和 100B 值）填充 100GB 的存储设备来完成的，直到系统报告“空间已满”。为了检查 LDS 优化对减少奇数块诱导的碎片的有效性，我们还在没有这种优化的 LDS 上运行了一项测试（标记为 plain-LDS）空间利用率的比较如图 17 所示。从图中我们可以看到，在不采取任何措施减少碎片的情况下，普通 LDS 的利用率最低，<br>图 16 显示了不同大小的累积版本数据的恢复时间。恢复成本主要来自加载版本数据的 I/O 成本和执行 trim 的 CPU 成本。虽然执行 trim 的过程对所有系统都是类似的，但花费的时间与版本数据大小成正比，对于 3MB 版本，需要 0.1 秒<br><br>容纳大约&nbsp;97%97%&nbsp;f2fs、&nbsp;93%93%&nbsp;ext4 和&nbsp;94%94%&nbsp;btrfs 的键值对数量。我们的调查表明，空间浪费主要来自奇数块。通过上述碎片减少优化，LDS 在所有系统中实现了最佳空间利用率。文件系统的低效主要来自 FS 索引引起的空间开销，这在 f2fs 中更为明显，因为它需要相当多的块来存储节点地址表。<br><br>尽管 LDS 被设计为 LSM 树的原始设备空间管理器，但它很容易支持使用预分配文件空间的功能，但有一些限制，如 Section 3.6.1 中所述。在本小节中，我们进行了实验，以评估 LDS 使用来自三个代表性文件系统的预先分配的文件空间时的局限性，即文件系统干扰的影响。虽然 ext4 被称为就地更新文件系统，但其他两个是不合适的。更新文件系统。因此，我们继续在 ext4 分配的文件空间上使用 sync_file_range，并禁用 ext4 的日志，因为在写入 LSM 树数据时，inode 中的映射数据不会更新。在 f2fs 或 btrfs 预先分配的文件空间上，使用 fsync 来保证更新的映射数据与 LSM 树数据一起同步。评估结果表明，文件系统对预分配文件空间的干扰会引起两种开销。第一种是刷新<br>在默认提交策略中从用户空间到 OS 缓存的 WAL，其中 LevelDB 的每个日志记录请求都转换为 urite 系统调用，并最终由分配文件空间的相应文件系统处理。这种开销与 LevelDB 直接在文件系统上运行时的开销几乎相同，如图 11 所示的日志成本。使用 mmap 实现 fushing 可以显着减少 WAL 开销，因为将日志发送到 OS 缓存将是一个 memcpy 操作，在建立日志区域的页表条目后不会导致系统调用。<br><img src="读书笔记\曹老师2019年论文\assets\671f80493a8e186f297aafcbc07613ad_md5.png"><br>图 17：当系统在 100GB 存储设备上报告“space full”时插入的键值对总数。<br>另一种是由文件系统干扰引起的 I/O 开销，它主要存在于 out-of-placeupdate 文件系统上，因为它们总是为任何 LDS 写入分配新的存储块，并且需要在同步 LDS 数据时同步文件元数据。例如，在 HDD 上，使用 btrfs 分配的文件空间的开销大约&nbsp;2.5×2.5×&nbsp;高于使用原始空间，这相当于在 btrfs 上运行 LevelDB 的常规方式，因为无法避免 wandering-update。此值适用于&nbsp;1.4×1.4×&nbsp;f2fs 分配的文件空间，或在 f2fs 上运行 LevelDB 开销的一半，因为已为预先分配的文件空间建立了 NAT，并且大多数情况下，在同步 LDS 数据时需要同步一个间接节点 [33]。对于 ext4 分配的文件空间，虽然它不需要更新文件元数据，但开销相当于使用原始空间。例如，在预分配过程中，ext4 确定将属于预分配文件的所有物理块，并创建一个将文件空间（文件偏移量）映射到物理块空间（即 LBA）的 inode。由于文件系统就地更新，后续从 LDS 到文件空间的写入直接进入相应的物理块，并且仅同步文件空间中写入的数据就足以保证数据一致性，因为 inode 中的映射信息不会改变。因此，LDS 可以像处理原始空间一样处理 ext4 分配的文件空间。<br><br><br>SQL Server [64] 等传统数据库系统使用 B+trees 作为后端结构，这对于读取来说非常出色，但在写入方面性能很差。分形树 [46] 是作为 LSM 树的写入优化数据结构，它维护一个全局 B+树，每个节点都有一个缓冲区。更新通过中间节点的缓冲区批量下降到 B + 树的叶节点，这与 LSM 树提出的想法类似 [46]。写入优化的数据结构已被广泛用作现代数据存储中的存储引擎 [7， 19， 54， 61， 65， 66]。本文重点介绍优化基于 LSM 树的键值存储的存储堆栈<br><br>随着 LSM 树在大型数据存储中的普及，已经研究了大量技术来优化 LSM 树的写入效率。大多数工作都有助于减少写入放大。VT 树 [59] 通过仅合并块的重叠部分来优化高度顺序工作负载中的写入放大。Wisckey [37] 通过将值从 LSM 树中移出到单独的日志中来减少值诱导的放大，类似于 Bitcask [58] 中实现的方法，即使用内存中哈希表为值日志编制索引。LSM-trie [69] 使用键的哈希前缀来索引级别，通过允许级别内的重叠块，它显着减少了写入放大，如 Cassandra [1] 中的大小分层压缩策略或阶梯合并<br><br>机制 [24] 可以。TRIAD [3] 通过利用倾斜的工作负载和延迟压缩过程来优化写入放大。PebblesDB [52] 引入了碎片化 LSM 树 （FLSM） 机制，该机制允许级别内的重叠块以避免数据重写，并为用户提供可调整的参数，以便在写入 I/O 和读取延迟之间进行权衡。<br>我们的工作与上述现有工作不同且正交，因为我们通过提供 LSM 树友好的磁盘数据布局来优化 LSM 树。<br><br>在数据库字段初期，数据直接存储在容量较小的块存储上，应用程序负责块 / 段分配和数据一致性 [36]。该文件系统旨在通过使用统一的文件级块组织存储空间并在数据对象和底层存储空间之间引入间接映射来提供任意大小对象的目录层次结构抽象和数据存储 [41， 62]。Stonebraker [62] 研究了由不同的操作系统组件（包括文件系统）引起的数据库系统开销。Engler 和 Kaashoek [14] 提议完全消除操作系统抽象，并允许应用程序从硬件中选择高效的实现。不过。在接下来的几十年里，随着存储容量的快速增长，与多个应用程序共享一个存储并将复杂的存储管理工作转移到文件系统是有利可图的。然而，随着大数据的出现，例如大规模的键值存储 [7， 19， 69]，数据大小很容易超出存储容量，而负责大型和统一数据对象的应用程序从文件系统层中受益匪浅。相比之下，由于额外的间接和一致性实施，文件系统可能会对高性能数据存储产生负面影响例如，最近关于键值存储的工作仍然存在<br>由于观察到的性能下降，它们的数据绕过了文件系统 [48]。Papagiannis 等人提出了系统 Iris [49]，以减少低延迟存储设备的 I/O 路径中明显的软件开销。NVMKV [39] 是一种键值存储，它通过将每个单独的键值对直接哈希到 SSD 的稀疏 FTL 空间中，迈出了根本性的一步。然而，他们并没有明确量化不同文件系统的数据部署造成的开销，LSM 树应用程序如何受到影响仍不清楚。在本文中，对间接费用进行了深入研究<br>由于通过代表性文件系统存储 LSM 树，我们设计了 LDS 以 LSM 树结构直接管理存储，以提供高性能的键值存储。<br><br>新技术（如多流 NVM）已被预先用于感知应用层数据流 [27]，这可能是 LDS 存储 LSM 树的机会<br>data 以 NVM 友好的方式。FlashBlade [63] 构建了一个基于 flash 的存储阵列，该阵列将 flash 转换功能移动到阵列级软件中，并要求软件仔细地将用户数据调节为顺序流。LDS 提供了一种在应用层管理 flash 转换功能的简单方法，因为它消除了存储堆栈中的额外 I/O 并保留了 LSM 树的连续 I/O 模式。其他一些工作利用了新存储的特性<br>来自应用程序层的媒体。LOCS [67] 通过将 SSD 的通道暴露给上层应用程序来挖掘 SSD 的带宽利用率，从而优化了 LSM 树应用程序的性能。Lee 等人 [34] 提出了一个应用程序管理的 flash 系统，它解决了应用程序层日志记录和 flash 层日志记录之间的差异，从而提高了应用程序性能和 fash 管理开销。Colgrove 等人 [10] 引入了一种存储系统，它使用自定义内核模块绕过内核块设备，并将应用程序级随机写入转换为压缩的顺序写入，以使底层闪存阵列受益 [63]。虽然 LDS 为基于 LSM 树的 LSM 提供了高性能<br>键值存储，如果考虑到 SSD 的内部特性，则可以从 LDS 中获得潜在的好处。例如，可以消除闪存中昂贵的垃圾回收操作，因为 LDS 总是丢弃插槽单元中的存储空间，无需数据迁移即可擦除。此外，我们计划将 LDS 增强为闪存感知，以便它可以执行磨损均衡工作，这对 LDS 来说更简单、更方便。<br><br>在本文中，我们介绍了 LDS，这是一种基于 Log-structured-merge-trec 的直接存储系统，它采用 LSM 树结构（一种广泛用于大规模键值存储的结构）来管理底层存储空间，从而保留 LSM 树的全部属性。基于 LevelDB 的 LDS 原型表明，与在最先进的文件系统上运行的 LSM 树相比，LDS 提供了显著的性能改进和 I/O 减少。<br><br>我们感谢我们的牧羊人 Vijay Chidambaram 和 Russell Sears 为改进本文提供的大量帮助，并感谢匿名审稿人的宝贵意见我们还感谢 Mark Callaghan 的有益反馈。这项工作部分得到了武汉光电子国家实验室基金（资助号0106187015和0106187027）和美国国家科学基金会（资助号：CCF 1629625<br><br>[1] 阿帕奇。2016. 压缩类型。http：/ /cassandra.apache org/doc/latest/operating/compaction.html.(2016)<br><br>[2Bek All YaWn rc SJan Value Store.在 ACM SIGMETRICS 性能评估评论中，第 40 卷.ACM，5364。[3]Oana Balmau、Diego Didona、Rachid Guerraoui、Willy Zwaenepoel、Huapeng Yuan、Aashray Arora、Karan Gupta 和 Pavan Konka。2017. TRIAD：在日志结构化键值存储中的 Mem、Disk 和 Log 之间创建协同作用。2017 年 USENIX 年度技术会议 （USENIX ATC 17）。[4]Michael A Bender、Martin Farach-Colton、Jeremy T Fineman、Yonatan R Fogel、Bradley C Kuszmaul 和 Jelani Nelson。20077 Cache-Oblivious Streaming B 树。在第九届年度 ACM 研讨会的会议记录中，关于并行算法和 ar chifecfures。ACM， 8192 [5]Gerth Stolting Brodal 和 Rolf Fagerberg.2003. 外部存储器词典的下限。第 14 届年度 ACM-SIAM 离散算法研讨会论文集。工业与应用数学学会，546554。[ Ad Graph 遍历。在 SODA 中。859860 [7]EChefBmt H Fikes.and Robert E Gruber.2008.Bigtable： A Distributed Storage System for Structured Data.ACM Transactions on Computer Systems （TOCS） 26， 2 （2008）.[8] Vijay Chidambaram、Thanumalayan Sankaranarayana Pillai、An-e drea C. Arpaci-Duseau 和 Remzi H. Arpaci-Dusseau。2013. 乐观崩溃一致性。在 Tuenty-Fourth ACM 操作系统原理研讨会 （SOSP 13） 的会议记录中。228243 [9 Vilay ChidambaramDshar Sharma Andrea C Arpaci-Duseon dering.第 1O 届 USENIX 文件和存储技术研讨会 （FAST '12） 的会议记录。加利福尼亚州圣何塞 10 e Wang.2015. Purity：从商用组件构建快速、高度可用的企业级闪存存储。在 2015 年 ACM SIGMOD 数据管理国际会议 （SIGMOD '15） 的会议记录中。ACM，16831694。[11] 布莱恩 F. Cooper、Raghu Ramakrishnan、Utkarsh Srivastava、Adam Silberstein、Philip Bohannon、Hans-Arno Jacobsen、Nick Puz、Daniel Weaver 和 Ramana Yerneni。2008. PNUTS：Yahoo！ 的托管数据服务平台。VLDB Endow 论文集。1、2（2008 年 8 月），12771288 [12] DataStax。2017. DSE 5.1 管理员指南：更改日志记录位置.https：//docs.datastax.com/en/dse/5.1/dse-admin/ tem.在第 4 届 USENIX 存储和文件系统热门话题研讨会 （HotStorage 12） 中。[ a （hbsom [18] Grery er d Y Pat 199tttx 操作系统设计和实现会议 USENIX 协会 [19] Sanjay Ghemawat 和 Jef Dean。2011. 水平IDB。http：/leveldb [20 d RDNS compaction-nuance.html.（2017） [21] 罗宾·德·菲尔系统 [22]胡小宇、伊万杰洛斯·埃莱夫塞里乌、罗伯特·哈斯、伊利亚斯·伊利亚迪斯和罗曼·普莱特卡。2009. 基于闪存的固态驱动器中的写入放大分析。在 SYSTOR 2009 会议记录中：以色列实验系统会议。ACM 的。[23]InfuxData， Inc. 2017 年。指标和事件的现代引擎 https： / /<a data-tooltip-position="top" aria-label="http://www.influxdata.com/" rel="noopener" class="external-link" href="http://www.influxdata.com/" target="_blank">www.influxdata.com/</a> - （2017）。<br>[24] HV Jagadish Ps Narayan Seidhar Seshadri S Sudashan 以及记录和仓储。在 VLDB，第 97 卷。1625 [25Wiaa J Ah Ah a ohn Reddy， Leif Walsh， et al. 2015.BetrFS：第 13 届 USENIX 文件与存储技术会议 （FAST '15） System.In 右优化写入优化文件。301315. [26 Some e gj ng Son 和 2013 年 USENIX 年度技术会议 （USENIX ATC 13.309320 [27] Jeong-Uk Kang、Jeeseok Hyun、Hyunjoo Maeng 和 Sangyeun Cho。2014. 多流固态驱动器。第 6 届 USENIX 存储和文件系统热门话题研讨会 （HotStor αge *14）。[28 Hyojun Kin， Nifin Stawaland rain Unguran.2012erRge （TOS）8,4 （2012） [ 29 Wwok-Hle Kimaiovong KwmA.Wgogki Baek Beomscok Naene Ahead Logging.在 Tuenty-First 国际会议论文集 30]AH Kihara 和 Satoshi Moriai 的建筑支持会议上。2006. 日志结构文件系统的 Linux 实现。ACM SIGOPS 操作系统评论 40， 3 （2006）， 102107 [31 TJ Kowalki.1990 FreckaThe Unix Fle System Check Program [32] Avinash Lakshman 和 Prashant Malik。2010. Cassandra：一种去中心化的结构化存储系统。ACM SIGOPS 操作系统评论 44， 2 （2010）， 3540。[33]Changman Lee、Dongho Sim、Jooyoung Hwang 和 Sangyeur Cho。2015.F2FS：用于闪存的新文件系统 Storage.In 13ti USENIX 文件和存储技术会议 （FAST '15）。[34] Sungjin Lee， Ming Liu， Sang Woo Jun， Shuotao Xu， Jihong Kim.和 Arvind Arvind。2016. 应用程序管理的 Flash。在第 14 届 USENIX 文件和存储技术会议 （FAST 16339353 [35] 中，Cheng Li、Philip Shilane、Fred Douglis、Darren Sawyer 和 Hyong Shim。2014. 断言 （！已定义（顺序 I/O））。在第 6 届 USENIX 存储和文件系统热门话题研讨会 （HotStorage 14） 中。 36 1 （1977）， 91104 [37] 兰月卢、Thanumalayan Sankaranarayana Pillai、Andrea C Arpaci-Duseau 和 Remzi H Arpaci-Dusseau。2016. WiscKey：在 SSD 敏感型存储中将键与值分开。在第 14 届 USENIX 文件和存储技术会议 （FAST '16） 中。133148 [38] Ao 马、Chris Dragga、Andrea C Arpaci-Dusseau、Remzi H ArpaciDusseau 和 Marshall Kirk Mckusick。2014. ffsck：快速文件系统检查器。ACM 存储汇刊 （TOS） 101 （2014） [39] Leonardo Marmol、Swaminathan Sundararaman、Nisha Talagala 和 Raju Rangaswami。2015. NVMKV：可扩展的轻量级。FTL 感知键值存储。在 2015 年 USEN1X 年度技术会议 （USENIX ATC 15）.207-219 [40] Avantika Mathur、Mingming Cao、Suparna Bhattacharya、Andreas Dilger、Alex Tomas 和 Laurent Vivier。2007. 新的 Ext4 文件系统：现状和未来计划。在 Linuz 研讨会论文集，第 2 卷中。Citeseer，2133 年。[41] 马歇尔·麦库西克、威廉·乔伊、塞缪尔·莱夫勒和罗伯特·法布里。1984. 用于 UNIX 的快速文件系统。ACM 计算机系统汇刊 （TOCS） 2， 3 （1984）， 181- 197 [2] MichalK0r [43] Changwoo Min， Kangnyeon Kim， Hyunjin Cho， Sang-Won Lee 和 Young Ik Eom.2012. SFS：在固态驱动器中随机写入被认为是有害的。在第 10 届 USENIX 文件和存储技术会议 （FAST 12） 中。[44] J. Mohan、R. Kadekodi 和 V Chidambaram。2017. 分析 Linux 文件系统中的 IO 放大。ArXiv 电子打印（2017 年 7 月）。arXiv：cs 的OS/1707 的。08514<br><br>[45] Rajesh Nishtala、Hans Fugal、Steven Grimm、Marc Kwiatkowski、Herman Lee、Harry C Li、Ryan McElroy、Mike Paleczny、Daniel Peek、Paul Saab 等人，2013 年。在 Facebook 扩展 Memcache。在第 10 届 USENIX 网络系统设计和实现研讨会 （NSDI 13） 中385398 [46] Patrick Oneil、Edward Cheng、Dieter Gawlick 和 Elizabeth Oneil。1996. 日志结构合并树 （LSM 树）。Act Informatica （1996 年）。[4] MikOwens 和 Grant Allen201 SQLite Srionale-Fere 和 Angelos Bilas。2016. Tucana：快速高效的纵向扩展键值存储的设计和实现。2016 年 USENIX 年度技术会议 （USENIX ATC '16）。[49An siars latency Storage Devices.ACM SIGOPS Operating Systems Review 50， 1 （2017）， 311. 50cth Jh P2002mon 加利福尼亚大学圣克鲁斯分校。[51] Tanalakya Vi Chmaram Duseau 和 Remzi H Arpaci-Dusseau。2014. 并非所有文件系统都是平等的：关于制作崩溃一致性应用程序的复杂性。在第 1I 届 USENIX 操作系统设计和实施会议论文集 OSDI14 中）。BroomfieldCO，433-448 [52 Pandian Rant R ohan Kadekod.Vjlay Chidymbaerems 和 wtae 吞吐量和 wtae 吞吐量和减少写入放大在第 26 届 ACM 操作系统原理会议记录 （SOSP 17） 的键值 Stores.In 论文集中。中国上海 [53]Remzi H. Arpaci-Dusseau 和 Andrea C. Arpaci-Dusseau.2015 年崩溃一致性：FSCK 和日志。<a data-tooltip-position="top" aria-label="http://pages.cs.wisc%E3%80%82edu/remzi/OSTEP/file-journaling.pdf%E3%80%82%EF%BC%882015%EF%BC%89" rel="noopener" class="external-link" href="http://pages.cs.wisc%E3%80%82edu/remzi/OSTEP/file-journaling.pdf%E3%80%82%EF%BC%882015%EF%BC%89" target="_blank">http://pages.cs.wisc。edu/remzi/OSTEP/file-journaling.pdf。（2015）</a>. [54] 凯任和加思吉布森。2013. TABLEFS：提高本地文件系统中的元数据效率。2013 年 USENIX 年度技术会议 （USENIX ATC '13）。145156 [55 Ohad oacik dris M0139,3 （2013） [56] Mendel Rosenblum 和 John K Ousterhout。1992. 日志结构文件系统的设计和实现。ACM 计算机系统汇刊 （TOCS） 10， 1 （1992）。2652. [57] 罗素·西尔斯和拉古·拉马克里希南。2012. bLSM：通用日志结构化合并树。在 2012 年 ACM SIGMOD 数据管理国际会议 （SIGMOD *12） 的论文集中。ACM， 217228 [58 DJ Shebhy 和 DS/mith 2010 Bfeask A Log-Sru（tured Hash [59 Prg Workload-Independent Storage with VT-Trees.在 I1th USENIX 文件和存储技术会议 （FAST '13） 中。17- 30.[60] Kent Smith.2011 垃圾收集 SandFore， Flash Memory [61] SQ 2016it vhttps//ww [62Micrk Data [63 Pure torage.2017.Prom BieDatatoBis Itell ence htps： [64] ZaoHui Tangand Jamine Maclen.205. 数据挖掘 unth [65] okutek.伊恩。2013TokuDB： MySQL Performance， MariaDB [66] Mehul Nalin Vora.2011. 用于大规模数据的 Hadoop-HBase。2011 年计算机科学与 nefuwork 技术国际会议 （ICCSNT），第 1 卷。IEEE， 601605 [67] 王鹏、孙光宇、宋江、欧阳健、林世丁、张晨和丛健。2014 年。在 OpenChannel SSD 上基于 LSM 树的键值存储的高效设计和实现。在第九届欧洲计算机系统会议 （EuroSys '14） 的论文集中。ACM [68]Ext4 Wiki.2011. Ext4 写入请求的生命周期.https：/ext4.wiki kernel.org/index.php/Life_of_an_ext4_write_request。(2011).<br>[69] 吴兴波， 徐月海， 邵子力， 江松.2015. LSM-trie：基于 LSM 树的小数据超大型键值存储 2015 年 USENIX 年度技术会议 （USENIX ATC 15）。[70] Jingpei Yang， Ned Plasson， Greg GDis， Nisha Talagala，g 和 My Log.第 2 届 NVM/闪存与操作系统和工作负载交互研讨会 （INFLOW *14）]]></description><link>读书笔记\曹老师2019年论文\2024年9月12日_正文.html</link><guid isPermaLink="false">读书笔记/曹老师2019年论文/2024年9月12日_正文.md</guid><pubDate>Sat, 14 Sep 2024 07:30:47 GMT</pubDate><enclosure url="读书笔记\曹老师2019年论文\assets\c794693ecb2673dc13277a64a5570d9d_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;读书笔记\曹老师2019年论文\assets\c794693ecb2673dc13277a64a5570d9d_md5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[主题思想]]></title><description><![CDATA[ 
 <br><br>
<br>LSM ✅ 2024-09-09
<br>什么是<a data-href="直接存储系统" href="读书笔记\曹老师2019年论文\直接存储系统.html" class="internal-link" target="_self" rel="noopener">直接存储系统</a> ✅ 2024-09-09
<br>这篇论文的主题思想是探讨了在使用传统文件系统存储大型键值存储时，文件系统的索引机制如何对基于Log-Structured Merge Tree (LSM-tree) 的数据存储性能产生负面影响。作者通过实验发现，即使文件系统产生的索引I/O操作在大小上很小，但其数量远远超过实际用户数据的I/O操作，并且显著地降低了LSM-tree应用的性能。<br>为了解决这一问题，作者提出了一种名为LDS (LSM-tree Managed Storage) 的直接存储系统，该系统通过利用LSM-tree结构中写时复制的特点来管理存储空间并简化一致性控制，以此来充分利用LSM-tree的优势。实验结果表明，在硬盘驱动器(HDDs)上，LDS能够将LSM-tree的写入吞吐量提高1.8到3倍；而在固态硬盘(SSDs)上，则可以提高1.3到2.5倍。<br>此外，论文还讨论了新的存储技术如多流非易失性内存(NVM)对于LDS来说是一个机会，可以使LDS以更友好的方式存储LSM-tree的数据。LDS消除了存储堆栈中的额外I/O操作，并保留了LSM-tree的顺序I/O模式，从而提供了一种在应用程序层管理闪存转换功能的简便方法。<br>
处理的是大量小文件带来的文件系统管理的索引问题，所以干脆不从文件系统传递元数据，避免文件系统管理的麻烦
<br>[tab]<br><br>
<br>元数据往往比文件本身更重要，如何保证元数据不损坏的
<br>如何保证元数据以direct IO方式也可以保证顺序性的
<br>]]></description><link>读书笔记\曹老师2019年论文\曹老师2019年论文.html</link><guid isPermaLink="false">读书笔记/曹老师2019年论文/曹老师2019年论文.md</guid><pubDate>Mon, 09 Sep 2024 07:13:54 GMT</pubDate></item><item><title><![CDATA[论文总结]]></title><description><![CDATA[ 
 <br>这段文档详细介绍了基于Log-Structured Merge Tree（LSM Tree）的直接存储系统（LDS），其目标是实现一种能够直接管理存储空间而不依赖文件系统二级索引的存储系统，以优化操作性能。文档中提到的关键技术和流程如下：<br>
<br>
LSM Tree 在数据存储中的作用与挑战：LSM Tree 被广泛应用于大规模键值存储系统中，用于缓冲内存中的随机写操作，并以顺序写入的方式将数据持久化到磁盘存储中。然而，由于文件系统（如 Ext4、F2FS、BTRFS）在进行数据索引和文件系统本身的更新操作时，可能会引入额外的I/O操作，这些操作往往不是顺序的，从而影响了LSM Tree的性能。

<br>
LSM Tree与文件系统交互的挑战：通过分析文件系统（如 Ext4、F2FS、BTRFS）在存储LSM Tree数据时的行为，文档中发现这些系统的 lại级索引（如inode、bitmap）占用大量的存储空间进行非顺序读写操作，导致额外的I/O开销。这与LSM Tree的预期性能目标相悖。

<br>
直接存储系统（LDS）的设计：文档提出LDS是一种能够直接管理LSM Tree数据的系统，它通过自定义的数据结构与磁盘布局，避免了文件系统级别索引的额外开销。具体设计包括：

<br>磁盘布局优化：使用分区域存储策略（版本日志、备份日志和slot区域），实现高效的数据访问和内存操作。
<br>管理存储的一致性：通过版本和△版本来管理LSM树的数据状态和块存储位置的映射，以及支持优先的存储空间分配和高效的复制更新机制。
<br>日志优化：采用特别设计的日志对象格式和日志更新策略，以最小化日志记录操作的I/O，从而增强恢复过程的性能和一致性。


<br>
性能评估：通过与前人使用文件系统存储LSM Tree的系统做对比，实验表明LDS在HDD和SSD上均能够提高写入性能：在HDD上至少提高1.8倍，最高可达3倍；在SSD上至少提高1.3倍，获得更易于检索的读取性能增益。这得益于LDS直接管理存储空间，有效控制了额外的文件系统级别操作。

<br>
综合评估与前景展望：LDS为存储系统的高性能和一体化一致性提供了新的设计机会，为未来的大规模键值存储应用提供了优化存储策略的参考。随着未来固态存储和新存储技术（如多流NVM）的发展，LDS有望集成更多的存储特性，进一步提升数据存储系统的效率和扩展性。

<br>LDS通过引入直接存储管理和优化数据布局来解决现存的LSM Tree系统与文件系统层次之间性能与一致性的问题，成为一种针对性地提升基于LSM Tree存储系统性能的新方案。]]></description><link>读书笔记\曹老师2019年论文\论文总结.html</link><guid isPermaLink="false">读书笔记/曹老师2019年论文/论文总结.md</guid><pubDate>Thu, 19 Sep 2024 12:30:20 GMT</pubDate></item><item><title><![CDATA[直接存储系统]]></title><description><![CDATA[ 
 直接存储系统绕过传统文件系统，直接在应用层管理存储，提高写入吞吐量，适应LSM-tree等数据结构的顺序写入需求。]]></description><link>读书笔记\曹老师2019年论文\直接存储系统.html</link><guid isPermaLink="false">读书笔记/曹老师2019年论文/直接存储系统.md</guid><pubDate>Mon, 09 Sep 2024 02:14:55 GMT</pubDate></item><item><title><![CDATA[2024年9月5日_《金字塔原理》读书报告]]></title><description><![CDATA[ 
 《金字塔原理》介绍了自上而下的逻辑思维，强调结论先行和结构化分析在信息收集和问题解决中的重要性。归纳法和演绎法有助于理清逻辑，预设目的与结果能有效避免无用数据，提高效率。]]></description><link>读书笔记\2024年9月5日_《金字塔原理》读书报告.html</link><guid isPermaLink="false">读书笔记/2024年9月5日_《金字塔原理》读书报告.md</guid><pubDate>Sun, 08 Sep 2024 06:55:07 GMT</pubDate></item><item><title><![CDATA[2024年9月28日_《逻辑的力量》]]></title><description><![CDATA[<a class="tag" href="?query=tag:读书" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#读书</a> 
 <br>
<br><a href=".?query=tag:读书" class="tag" target="_blank" rel="noopener">#读书</a> 《逻辑的力量》 ➕ 2024-09-28 📅 2024-10-03 ✅ 2024-10-04
<br>看完了，不是很想写书评，把别人写的书评摘一点在下面，然后随便写点感悟好了。<br>从数学家的立场来分析逻辑的意义、架构，虽多抽象概念但读来并不枯燥无味，只是可能会冒犯一些自以为是的哲学家们，毕竟他们最喜欢的就是囔囔“现代逻辑无法证明为真”。最吸引人的是作者指出逻辑和现实生活中的用语有怎样的联系和区别，区分精准和迂腐颇有同感，更能理解我们日常发言的观点背后究竟是怎样的命题。<br>
下面是我自己的部分
<br>对我而说，在与人交往的层面上，我学习到了，很多时候聊天不能达成一致也不一定是因为自己或者他人的逻辑错误，而往往是逻辑的源头，每人的公理存在不同。此外，还有情感这个元逻辑的要素，是众多思绪的根源。要与人愉快聊天，首先就需要判断彼此处于哪个层次，然后如何可以思考到对方的层次，从而与人为友。<br><img src="读书笔记\assets\pasted-image-20241004090357.png"><br>本书名为《逻辑的力量》，最后的落脚点还是在如何正确的在生活中使用逻辑，从一个合理的情感出发点出发，目的是促进更和谐的社会。作者在书中有一些小的私货，不过影响不大，也不极端，作为论证的过程来说是可以接受的，这是后话。<br><br>逻辑的力量<br>
（英）郑乐隽<br>第三章 逻辑的方向性<br>
2024-10-01 09:30<br>
事实上，一个命题的逆转在逻辑上是独立于原命题的，这意味着两者之间是没有逻辑联系的。也就是说，它们中的一个为真，并不一定意味着另一个也为真，也不一定意味着另一个为假。<br>第四章 对立与谬误<br>
2024-10-01 09:33<br>
逻辑学、数学和科学都是发现什么事物为真的方法，但它们同时也是发现什么事物为假的方法。我坚信，承认出错的可能性，并找到发现错误的方法，是一个理性人的重要组成部分。（但是我可能是错的。）<br>
2024-10-01 10:48<br>
它意味着，任何指定的非白人处在完全相同的环境下，如果他们变成白人，那么他们将会更好地融入社会以及生活中。<br>
注:那不是特权是不能修改的<br>
2024-10-01 12:16<br>
科学实验的过程通常从一个假设开始，也就是说，科学家认为某个命题可能为真，但是它的真值目前还是未知的。<br>
注:真和真值的区别<br>
2024-10-01 12:18<br>
聪明的做法是，不基于它的正误做任何事，而是等待进一步的数据。<br>第五章 责备与责任<br>
2024-10-01 12:19<br>
但其实这里有非常多的促成因素。促成因素和“错误”一样吗？让我们来直面这个问题吧，生活中的一切都不只由一个因素造成，只是人们倾向于把责备的矛头指向一个因素，通常是一个人。<br>
2024-10-01 12:23<br>
逻辑连接词是将逻辑陈述连接起来，形成更大、更复杂的陈述的途径。<br>
注:逻辑运用到生活<br>
2024-10-01 14:58<br>
但是，用逻辑连接词“和”相连的因素结合体，才是真正导致了这样的结果的原因。<br>
2024-10-01 20:19<br>
我们需要理解体系，本案例中的体系就是人与人之间的关系。<br>第六章 关系<br>
2024-10-01 20:47<br>
有一个观点是：谁掌握权力，谁就应该负责打破循环。一些成功的项目侧重于通过促进警察和黑人群体之间的关系来改变两个“情感”的箭头。<br>
2024-10-01 21:45<br>
如果我们都能变得更加善于从特权和非特权的角度来看待事物，那么我们不仅能够更好地理解弱势群体的斗争，还能理解导致偏见和压迫的行为，无论这些行为是恶意的还是无知的。<br>第七章 如何成为正确的一方<br>
2024-10-01 21:46<br>
这么做就是在诱使某类人反驳你的逻辑，而不是抚平你的情绪。<br>
2024-10-01 21:47<br>
这种陈述不仅更准确，而且说出的事物更具成效，不再是愤怒的概括性陈述。<br>
2024-10-01 22:06<br>
房间里根本没有大象，所有的（零只）大象都有两个头。这与一个事实有关：从逻辑上讲，谎言意味着一切。<br>第二部分 逻辑的极限<br>
2024-10-01 22:35<br>
逻辑不够强大的另一个方面出现在我们需要说服其他人接受我们的论点的时候。事实证明，逻辑是检验真理的好方法，但这与说服他人接受真理是不同的。检验真理和传递真理是两件不同的事情。<br>
2024-10-01 23:12<br>
分形是一种数学现象，它在所有尺度上都是与自身相似的，所以如果你放大它的一小部分，那么这个小部分看起来是和整体一样的。<br>
注:递归<br>
2024-10-01 23:12<br>
在现实生活的争论中，我们会一直辩解，直到说服另一个人；或者，一直辩解到我们发现大家的根本出发点是完全不同的，除非我们能够改变他们的根本信仰，否则我们永远无法说服他们。<br>
2024-10-01 23:13<br>
应对怀疑态度是数学过程的重要组成部分：我们的目标是为合理的怀疑排除一切可能性。这与审判中“合理怀疑”的概念相似。<br>
2024-10-02 11:22<br>
每当某些人因为科学研究与他们自身的经验或者坚定的信念相矛盾而不相信这些研究时，这种类型的反对就会发生。<br>
2024-10-02 11:25<br>
但是，我们只有在使用了许多并非完全符合逻辑的过程，并且建立起最初的想法后，才能做这些。这也许就是数学“天才”这一传说的起源——数学工作开始的时候，常常存在一个神秘的灵感元素。但是，我们不能忘记在后续构建逻辑的过程中付出的艰苦努力。<br>
2024-10-02 11:27<br>
如果缺失情感的成分，那么逻辑、数学以及科学都很难被内化。<br>
2024-10-02 11:28<br>
然而，我不同意这个观点。我认为我们能够找到简化论证的方法，这些方法在捕捉论证本质的同时，还能以模因运作的方式激发情感和娱乐性。<br>
2024-10-02 11:28<br>
在本书的后续部分，我们将会看到逻辑存在局限的各种方式，以及情感是如何帮助我们超越这些局限的。我们尤其不应该让情感和逻辑针锋相对。它们并不是对立的，而是会通过共同作用让事物变得既合情合理，又值得相信。<br>第九章 悖论<br>
2024-10-02 11:41<br>
我们可以把一对陈述变成如下所述的循环悖论：（1）下面的表述是正确的。（2）上面的表述是错误<br>
2024-10-02 11:42<br>
故事的结尾是乌龟仍然坐在那里折磨阿喀琉斯，让他写下所有这些中间的陈述。很明显，这种情况将永远持续下去。<br>
2024-10-02 11:44<br>
第二种是虚假的悖论，即逻辑上的错误被隐藏在争论中，而这正是导致奇怪结果的原因。<br>
2024-10-02 11:45<br>
并非我们的世界观是错误的，而是我们需要更加谨慎地对待无穷大的事物和无穷小的事物。<br>
2024-10-02 11:53<br>
悖论警告我们应该限制自己对数学能做什么的期望。<br>
2024-10-02 11:55<br>
假设集合S由一切不属于自身的集合组成，那么这个集合S包含集合S吗？如果包含，那么集合S不包含集合S。如果不包含，那么集合S包含集合S。这是一个悖论。<br>
2024-10-02 11:57<br>
层级是由以下方面组成的：（1）经过谨慎定义的对象的集合。这些被称为集合。（2）集合的集合。这些有时被称为大集合。（3）大集合的集合。我们可能称之为超级大集合。（4）超级大集合的集合。我们可能称之为超级超级大集合。（5）……以此类推。<br>
2024-10-02 11:57<br>
重要的是要意识到，将概念划分为多个层级也可以被用来对付我们。<br>2024-10-02 20:57<br>
似乎存在这样一个过程，在通过这个过程后，一些符合逻辑的事物就会深深地植入我们的感受，于是我们接下来就可以通过感觉而不是逻辑来获取它们。<br>
2024-10-02 21:14<br>
事实上，博弈论的逻辑认为，背叛在逻辑上是一种精确意义上的最佳策略。<br>
2024-10-02 21:32<br>
这告诉我们，在所有他人行为的情境中，如果你背叛别人，那么你会得到更好的结果。在博弈论中，这被称为占优策略。<br>
2024-10-02 21:33<br>
现在，根据囚徒困境的逻辑，我们应该期望每个人都叛变。但令人振奋的是，这并不是普遍的情况。<br>第三部分 逻辑与情感<br>
2024-10-02 23:35<br>
我认为我们必须接受自己逻辑体系的起点，这样才能有所成就。<br>
2024-10-02 23:37<br>
范畴论都是一门专注于事物之间的联系以及它们所形成的体系的学科。<br>
后面的部分太长，导出存在问题，因此不写
]]></description><link>读书笔记\2024年9月28日_《逻辑的力量》.html</link><guid isPermaLink="false">读书笔记/2024年9月28日_《逻辑的力量》.md</guid><pubDate>Fri, 04 Oct 2024 09:45:50 GMT</pubDate><enclosure url="读书笔记\assets\pasted-image-20241004090357.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;读书笔记\assets\pasted-image-20241004090357.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2024年10月4日_闲书《深度说服》]]></title><description><![CDATA[ 
 <br>深度说服]]></description><link>读书笔记\2024年10月4日_闲书《深度说服》.html</link><guid isPermaLink="false">读书笔记/2024年10月4日_闲书《深度说服》.md</guid><pubDate>Fri, 04 Oct 2024 11:25:38 GMT</pubDate></item><item><title><![CDATA[读书笔记]]></title><description><![CDATA[ 
 <br>读书应用很多，有的可以直接在上面做笔记，如微信读书，Zotero。还可以利用插件五彩阅读来做笔记，都是比较好的选择。<br>
为什么需要在Obsidian中单独开一个文件夹来做笔记呢？我想，一方面是，读书笔记不光是摘录的部分，也包括读完后的读后感，这些资料总归需要一个整理的地方。再者，单开一个文件纳入管理，日后也便于找寻。]]></description><link>读书笔记\读书笔记.html</link><guid isPermaLink="false">读书笔记/读书笔记.md</guid><pubDate>Sun, 22 Sep 2024 13:10:35 GMT</pubDate></item><item><title><![CDATA[人性的弱点]]></title><description><![CDATA[ 
 ]]></description><link>读书笔记\人性的弱点.html</link><guid isPermaLink="false">读书笔记/人性的弱点.md</guid><pubDate>Sun, 13 Oct 2024 01:13:54 GMT</pubDate></item><item><title><![CDATA[2024-10-09 16:25]]></title><description><![CDATA[ 
 <br><br>标题虽然是《瓦尔登湖》，不过确实主要是对《深度工作》的想法。<br><br><br><br>当然，还没有开始看，刚刚看深度工作总结了4种深度状态的方式，我简单罗列一下（忘记了一种）<br>
<br>记者型：空闲的时候就可以进入工作状态，记者需要时刻进入工作状态因此是有一定深度工作基础的人才可以掌握的技巧
<br>习惯型：养成打卡习惯，用习惯和重复性事件刺激自己进入深度工作状态
<br>周期型：类似于DDL前的状态，放纵几天，然后几天内进入深度工作状态，也属于是比较难达成的状态；一般来说是由大的压力的情况下（DDL）容易进入，自己也体验过几次，不过普遍认为难以达成。因为几天的深度状态意味着要几天几乎完全不进行社交活动（深度工作），对于社交容易产生一定的愧疚感。
<br>《瓦尔登湖》全书是24w字，虽然还没有开始看，不过这个字数也不是很多。读书方面，我打算再看完《深度工作》后，夹杂一本非方法论书来看，可以是中文经典也可以是《瓦尔登湖》，然后就看《心流+认识心流》二部曲。然后还有可以练习，这些书讲的内容可以互相印证，属于一种方法论。<br>可以形成一种习惯用于进入深度工作（大概花费90分钟），我个人认为我的启动条件是散步+咖啡。尼采称赞过散步，我个人也觉得散步算是提高心神的好方法，咖啡就不用说了，淡咖就足以维持我精神状态在一个比较好的状态。当然，一切还要再睡眠情况较好和没有大事发生影响心神状态的前提下。<br><br>看完了，没有什么特别的想法，好好去践行就好了。]]></description><link>读书笔记\深度工作.html</link><guid isPermaLink="false">读书笔记/深度工作.md</guid><pubDate>Fri, 11 Oct 2024 12:42:22 GMT</pubDate></item><item><title><![CDATA[数字极简]]></title><description><![CDATA[<a class="tag" href="?query=tag:读书" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#读书</a> 
 <br>
<br><a href=".?query=tag:读书" class="tag" target="_blank" rel="noopener">#读书</a> 《<a class="internal-link" data-href="数字极简.md" href="读书笔记\数字极简.html" target="_self" rel="noopener">数字极简</a>》 ✅ 2024-10-08
<br><br>数字极简的想法我大概也有了好几年，大概从初中开始发现自己控制不了看手机我就有了类似的想法。不过，那时控制能力还不是很强，心中玩性炽热，加上没有对应的方法论，没有解决措施，到了现在。<br>书中给数字极简的目的我很喜欢，掌握自己做什么的能力。我想要能够决定自己去做什么，而不是在网络中得到什么。很多时候浏览网页，翻来翻去，就是为了得到可能的心里快感，这种类似赌博的心理是不好的，是不确定的，同时一定程度上是浪费时间的。在掌握自己看什么，不看什么后，才好得到内心的满足。<br>我也希望得到内心的满足，首先就是卸载了稀土APP/这是书中看到的一种方式，这种咨询APP反正可以在电脑上进行查看，在手机上卸载不会影响咨询的获取，同时也阻止自己随时随地翻看手机的想法。以前也曾经试过卸载B站，后来还是下回来了，那这基本上就是最大的挑战了。<br>再就是，可以减少关注的博主数量。如果不在视频平台去执行这点，那RSS确实仍然是一个好的选择。FOLLOW出后可以官网一下，现在对我来说，我是用Thunerbird的RSS能力去扒小众软件和果核剥壳的内容，用被动提醒的方式减少阅读这两个大头论坛的时间。Thunderbird还可以进行筛选，从而过滤对我来说无用的信息（还是挺多的）。<br><br>今天看完全篇了，其实整本书要传递的内容就是如何远离手机低质量的娱乐活动。手机是和人随身携带的媒介，其能力之通用之丰富，引起了希望通过人们注意力来赚钱的另一批人，他们利用注意力赚钱。后面的几篇阐述了一些帮助实现数字清除的方案，如定期访问社交媒体，避免点赞的简单交流诱惑，使用老人机代替智能手机，将社交媒体定期和定点（在PC）上执行。<br>总得来说，就是要避免低质量娱乐的随时随地，减少盲目娱乐的机会和时间。<br>
我对社交媒体采用的简单交流诱惑挺有体会的，在QQ上连续说了半个小时的话，如果面对面讲5分钟左右就可以讲明白讲清楚。把一些不容易说清楚的事情（生活事情）放在网络上聊天，无疑是费事费力，吃力不讨好还容易因为缺少实时性和缺少非语言之外的细节从而造成误解。<br>一些的交流都不如线下交流，我深刻认识到线下与人沟通的重要性。人真正重要的对象可能只有150个（我忘记了啥理论），那么网上那么多“好友”，只是短暂地在某个时间和自己有一定的交集而已，这种交流维持与不维持其实对自己的实际生活都没有太大的影响。]]></description><link>读书笔记\数字极简.html</link><guid isPermaLink="false">读书笔记/数字极简.md</guid><pubDate>Tue, 08 Oct 2024 03:59:05 GMT</pubDate></item><item><title><![CDATA[@@插入当前格式化的日期时间]]></title><description><![CDATA[ 
 <br>打算做的第一个项目、简单点的文字热串替换，难点可能在于：<br>
<br>@是不是特殊符号
<br>如何插入格式化的日期时间
<br>不涉及类和复杂逻辑。<br>
2024-09-27 08/16 <br>
<br>实现了、不过出现了会根据输入法状态分配全角或者半角的冒号的问题
]]></description><link>项目\ahk学习\@@插入当前格式化的日期时间.html</link><guid isPermaLink="false">项目/ahk学习/@@插入当前格式化的日期时间.md</guid><pubDate>Fri, 27 Sep 2024 00:23:43 GMT</pubDate></item><item><title><![CDATA[2024-10-11AHK截屏]]></title><description><![CDATA[ 
 <br>在 AutoHotkey 中，你可以使用 ImageSearch 函数来复制当前鼠标光标所在位置的屏幕区域。以下是一个示例脚本，展示了如何实现这一功能：<br>; 定义捕获区域的宽度和高度
CaptureWidth := 100  ; 宽度
CaptureHeight := 100  ; 高度

; 获取当前鼠标光标的位置
MouseGetPos, MouseX, MouseY

; 计算捕获区域的起始和结束坐标
StartX := MouseX - CaptureWidth // 2
StartY := MouseY - CaptureHeight // 2
EndX := MouseX + CaptureWidth // 2
EndY := MouseY + CaptureHeight // 2

; 确保捕获区域不会超出屏幕边界
StartX := Max(0, StartX)
StartY := Max(0, StartY)
EndX := Min(A_ScreenWidth, EndX)
EndY := Min(A_ScreenHeight, EndY)

; 创建一个新的位图对象来存储捕获的图像
pToken := Gdip_Startup()
pBitmap := Gdip_BitmapFromScreen(StartX "|" StartY "|" (EndX - StartX) "|" (EndY - StartY))

; 保存捕获的图像到文件
Gdip_SaveBitmapToFile(pBitmap, "captured_image.png")

; 释放资源
Gdip_DisposeImage(pBitmap)
Gdip_Shutdown(pToken)

MsgBox, 捕获的图像已保存到 captured_image.png
复制<br><br>
<br>定义捕获区域的宽度和高度：CaptureWidth 和 CaptureHeight 变量定义了要捕获的区域的大小。
<br>获取当前鼠标光标的位置：MouseGetPos 函数获取当前鼠标光标的位置。
<br>计算捕获区域的起始和结束坐标：使用鼠标光标的位置计算捕获区域的起始和结束坐标。
<br>确保捕获区域不会超出屏幕边界：使用 Max 和 Min 函数确保捕获区域不会超出屏幕边界。
<br>创建一个新的位图对象来存储捕获的图像：使用 Gdip_BitmapFromScreen 函数捕获指定区域的图像，并将其存储在 pBitmap 变量中。
<br>保存捕获的图像到文件：使用 Gdip_SaveBitmapToFile 函数将捕获的图像保存到 captured_image.png 文件中。
<br>释放资源：使用 Gdip_DisposeImage 和 Gdip_Shutdown 函数释放资源。
<br><br>
<br>你需要安装 <a data-tooltip-position="top" aria-label="https://github.com/mmikeww/AHKv2-Gdip" rel="noopener" class="external-link" href="https://github.com/mmikeww/AHKv2-Gdip" target="_blank">Gdip</a> 库来使用 GDI+ 功能。
<br>确保在脚本开头包含 #Include Gdip.ahk 语句来加载 Gdip 库。
<br>通过这种方式，你可以在 AutoHotkey 中复制当前鼠标光标所在位置的屏幕区域，并将其保存到一个图像文件中。]]></description><link>项目\ahk学习\2024-10-11ahk截屏.html</link><guid isPermaLink="false">项目/ahk学习/2024-10-11AHK截屏.md</guid><pubDate>Thu, 10 Oct 2024 23:26:31 GMT</pubDate></item><item><title><![CDATA[2024年10月8日_关于AHK]]></title><description><![CDATA[<a class="tag" href="?query=tag:灵感" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#灵感</a> <a class="tag" href="?query=tag:AHK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AHK</a> <a class="tag" href="?query=tag:目录" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#目录</a> 
 <br>想到一些东西，自己写程序还是需要项目驱动，一般在code里执行（当然ahk可以直接用文本编辑器），这是工具而不是目的。<br>在cherry中启用了一个ahk2.0语法的智能体，也可以把下面的一些需求问问智能体看看效果。只要不是有窗口类型的，应该都可以很快得到验证。<br>
我来想想目的，把下面的东西使用AHK来完成<br><br>
<br>打开一组特定的网址（用edge，这个应该比较简单）
<br>Run 指定可以大概网址<br>
<br>可以运行Obsidian-uri 指令么？
<br>至少简单的Run是不行的：<br>
请注意，Run命令可以处理包含http://或https://的完整URL，所以即使您的前一个网址没有http://协议前缀，Run命令也会默认尝试使用http://打开它。如果想要确保使用https://，最好明确写出协议前缀。
<br><br>
<br>
搞类似vscode 的ctrl+k/ctrl+o 的效果（其实这个已经有前端案例了，不过我认为ahk会快一些） <a href=".?query=tag:灵感" class="tag" target="_blank" rel="noopener">#灵感</a> <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener">#AHK</a> ❌ 2024-10-09

<br>
使用@@语法快速插入当时时刻

<br><a data-href="字符连接" href="项目\ahk学习\字符连接.html" class="internal-link" target="_self" rel="noopener">字符连接</a>
<br>使用剪贴板的方式，成功将半角的冒号打印出来，之前都是会根据输入法的变化而变化: <a data-tooltip-position="top" aria-label="file:%5C%5CE:%5CBox%5CProjects%5Cahk@@-date_time.ahk" rel="noopener" class="external-link" href="file:\\E:\\Box\Projects\ahk@@-date_time.ahk" target="_blank">ahk文件</a>


<br>
<a href=".?query=tag:目录" class="tag" target="_blank" rel="noopener">#目录</a> <a data-tooltip-position="top" aria-label="file:%5C%5CE:%5CBox%5CProjects%5Cahk" rel="noopener" class="external-link" href="file:\\E:\\Box\Projects\ahk" target="_blank">ahk项目目录</a> ✅ 2024-10-08

<br>
实现浏览器访问Obsidian-uri链接的方式对文本进行简单的访问<br>
之后再看复杂的东西<br>
2024-10-08 22:49 Run可以带% 将链接文本（使用引号）直接视作参数

]]></description><link>项目\ahk学习\2024年10月8日_关于ahk.html</link><guid isPermaLink="false">项目/ahk学习/2024年10月8日_关于AHK.md</guid><pubDate>Sun, 13 Oct 2024 06:28:18 GMT</pubDate></item><item><title><![CDATA[2024-10-09 11:26 "AHK如何设计弹窗"]]></title><description><![CDATA[ 
 <br>
<br>AHK进行窗口设计，需要网页设计么 📅 2024-10-09 ✅ 2024-10-09
<br>在AutoHotkey中，您可以使用 MsgBox 命令来创建一个简单的弹窗。如果您使用的是AutoHotkey 2.0，语法有些变化。以下是AutoHotkey 1.0和2.0版本中创建弹窗的示例。<br>
[tab]\<br><br><br>MsgBox, 36, 标题, 这是带有是/否按钮的弹窗示例。
IfMsgBox Yes
{
    MsgBox, 您点击了是。
}
Else
{
    MsgBox, 您点击了否。
}
复制<br><br>response := MsgBox("这是带有是/否按钮的弹窗示例。", "标题", "YN")
if response = "Yes"
{
    MsgBox "您点击了是。"
}
else
{
    MsgBox "您点击了否。"
}
复制<br>MsgBox指令（WIN）用于调用系统弹窗，如上，第一个参数是窗内文字，第二个是标题，第三个是按钮类型。<br><br>
<br>Y：表示“是”按钮。
<br>N：表示“否”按钮。
<br>O：表示“确定”按钮。
<br>C：表示“取消”按钮。
<br>A：表示“重试”按钮。
<br>I：表示“忽略”按钮。
<br>B：表示“中止”按钮。
<br><br>使用InputBox函数，同样也是第三个参数作为选项（options）；第四个参数用于设置超时时间。<br>
<br>timeoutSeconds := 10：定义一个变量 timeoutSeconds 并设置其值为10，表示输入框的超时时间为10秒。
<br><br><br><img src="lib\media\pasted-image-20241009114123.png"><br>密码样式（隐蔽）：<br>response := InputBox "请输入您的密码：", "输入示例", "Password"
if ErrorLevel  ; 检查用户是否点击了取消按钮。
{
    MsgBox "您取消了输入。"
}
else
{
    MsgBox "您输入的密码是：" .response.Value
}
复制<br><br><img src="lib\media\pasted-image-20241009114325.png"><br>ErrorLevel 没有全局声明，实际上 global ErrorLevel := -1 在前面声明就好了，也许是单独的文本编辑器的问题。<br><br>在AutoHotkey (AHK) 中，除了 InputBox 之外，还有几种其他方式可以接受用户输入。以下是几种常见的输入方法：<br>
<br>AHK如何通过命令行传参 📅 2024-10-09 ✅ 2024-10-09
<br>
<br>命令行参数：如果你的脚本是通过命令行启动的，你可以直接从%0%到%9%获取命令行参数。%0%表示传递给脚本的参数数量，%1%到%9%分别表示第一个到第九个参数。
<br>
<br>AHK如何进行GUI设计 📅 2024-10-09 ✅ 2024-10-09
<br>
<br>Gui：你可以创 建一个图形用户界面（GUI）来接受用户输入。下面是一个简单的示例，展示了如何创建一个包含编辑框的GUI来获取用户输入：
<br>Gui, Add, Edit, vUserInput, Enter your input here
Gui, Add, Button, gSubmit, Submit
Gui, Show,, Input Example
return

Submit:
Gui, Submit
MsgBox You entered: %UserInput%
return

GuiClose:
ExitApp
复制<br>
<br>FileRead：如果你希望用户从文件中提供输入，可以使用FileRead命令来读取文件内容。例如：
<br>FileRead, UserInput, C:\path\to\your\file.txt
MsgBox The file contents are:`n%UserInput%
复制<br>
<br>ClipBoard：用户可以通过剪贴板提供输入。你可以使用ClipWait命令等待剪贴板内容，然后使用Clipboard变量获取内容。例如：
<br>MsgBox Please copy your input to the clipboard, then press OK.
ClipWait
MsgBox You copied:`n%Clipboard%
复制<br>
<br>AHK输入：COM对象和外部应用程序 📅 2024-10-09 ✅ 2024-10-09
<br>
<br>COM对象和外部应用程序：通过使用COM对象或与其他应用程序（如Excel、Word等）交互，你可以从这些应用程序中获取数据。
<br>每种方法都有其适用的场景，选择哪种方法取决于你的具体需求和应用场景。<br><br>在AutoHotkey中，Submit 和 GuiClose 并不是传统意义上的“函数”，而是被称作“标签”（Label）。标签在AHK中用于定义脚本的特定行为，例如响应用户操作或处理特定事件。<br>在你的GUI示例中：<br>
<br>Submit: 是一个标签，当用户点击“Submit”按钮时，脚本会跳转到这个标签并执行其后的代码。这是一种处理按钮点击事件的方式。
<br>GuiClose: 也是一个标签，它定义了当GUI窗口被关闭时应该执行的操作。在这个例子中，GuiClose:标签内的代码会退出应用。
<br>以下是你的GUI示例，稍微修改以更清楚地展示标签的作用：<br>; 创建GUI窗口，添加一个编辑框和一个按钮
Gui, Add, Edit, vUserInput, Enter your input here
Gui, Add, Button, gSubmit, Submit
Gui, Show,, Input Example
return

; Submit标签：处理按钮点击事件
Submit:
Gui, Submit  ; 将GUI中的输入数据提交到相应的变量中
MsgBox You entered: %UserInput%
return

; GuiClose标签：处理GUI窗口关闭事件
GuiClose:
ExitApp  ; 退出应用程序
复制<br>在这个脚本中：<br>
<br>Gui, Add, Edit, vUserInput, Enter your input here：添加一个编辑框到GUI，并将其值绑定到变量UserInput。
<br>Gui, Add, Button, gSubmit, Submit：添加一个按钮，当点击时跳转到Submit标签。
<br>Gui, Show,, Input Example：显示GUI窗口。
<br>Submit:标签定义了按钮点击事件的处理逻辑。
<br>GuiClose:标签定义了GUI窗口关闭事件的处理逻辑。
<br>这种使用标签来处理事件的方式是AutoHotkey中常见的一种编程模式。]]></description><link>项目\ahk学习\2024年10月9日_ahk弹窗输入.html</link><guid isPermaLink="false">项目/ahk学习/2024年10月9日_AHK弹窗输入.md</guid><pubDate>Wed, 09 Oct 2024 13:45:43 GMT</pubDate><enclosure url="lib\media\pasted-image-20241009114123.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20241009114123.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[并排]]></title><description><![CDATA[ 
 <br><br>元素排列：在于对于按键位置的排列，如下所示：<br>runButton := mainWindow.Add("Button", "w40 h40", "运行")
runButton.OnEvent("Click", runCommand)

; 添加“取消”按钮
cancelButton := mainWindow.Add("Button", "xs+50 ys w40 h40", "取消")
cancelButton.OnEvent("Click", cancelCommand)
复制<br>将后面的按键的位置设置为前一个（父元素？）的相对位置即可，前个元素的位置时默认设置的。<br><br>这个应该要依赖windows的一些内置库，可以尝试怎么做。<br>
<br>
<a data-href="DLLCALL的HOOK函数" href="项目\ahk学习\dllcall的hook函数.html" class="internal-link" target="_self" rel="noopener">DLLCALL的HOOK函数</a>

<br>
实现AHK窗口的拖拽和缩放能力

]]></description><link>项目\ahk学习\并排和可以拖动.html</link><guid isPermaLink="false">项目/ahk学习/并排和可以拖动.md</guid><pubDate>Sat, 12 Oct 2024 11:35:29 GMT</pubDate></item><item><title><![CDATA[语法]]></title><description><![CDATA[ 
 <br>看了不少、基本上语法比较简答，具体需要自己去实践才行，注意是v2的语法和项目才值得参考。<br>
<br><a data-tooltip-position="top" aria-label="https://wyagd001.github.io/v2/docs/scripts/index.htm?mode=dark" rel="noopener" class="external-link" href="https://wyagd001.github.io/v2/docs/scripts/index.htm?mode=dark" target="_blank">Script 脚本展示 | AutoHotkey v2 (wyagd001.github.io)</a>
<br><a data-tooltip-position="top" aria-label="https://wyagd001.github.io/v2/docs/" rel="noopener" class="external-link" href="https://wyagd001.github.io/v2/docs/" target="_blank">快速参考 | AutoHotkey v2 (wyagd001.github.io)</a>

<br>新手入门指南、前期前端可以多看看


]]></description><link>项目\ahk学习\语法.html</link><guid isPermaLink="false">项目/ahk学习/语法.md</guid><pubDate>Thu, 26 Sep 2024 23:56:30 GMT</pubDate></item><item><title><![CDATA[字符连接]]></title><description><![CDATA[ 
 <br>您的脚本总体上是正确的，但有一些细节可以优化和调整，以确保它在各种情况下都能正常工作。以下是经过优化和调整后的脚本：<br>::@@::
    FormatTime, Timestamp,, yyyy-MM-dd HH:mm  ; 获取当前时间并格式化为 yyyy-MM-dd HH:mm 格式
    Clipboard := Timestamp . " "  ; 将格式化后的时间戳复制到剪贴板，并在末尾添加一个空格
    Send ^v  ; 发送粘贴命令
    Sleep, 50  ; 等待50毫秒以确保粘贴完成
    StringReplace, Clipboard, Clipboard, :, :, All  ; 确保剪贴板中的冒号是半角
return
复制<br><br>
<br>
字符串连接操作符：在 Clipboard := Timestamp . " " 中，使用 . 操作符来连接字符串，而不是 +。在 AHK 中，字符串连接应该使用 . 操作符，+ 通常用于数字相加。

<br>
注释：将注释中的格式描述改为 yyyy-MM-dd HH:mm，以匹配 FormatTime 命令中的实际格式。

<br>
确保冒号是半角：虽然 StringReplace 命令在这里是多余的，因为它不会改变任何内容（半角冒号替换半角冒号），但保留它可以确保脚本的意图明确。

<br><br>
<br>::@@::：定义热字符串 @@，当输入 @@ 时，触发后续代码块。
<br>FormatTime, Timestamp,, yyyy-MM-dd HH:mm：获取当前时间，并格式化为 yyyy-MM-dd HH:mm 格式，存储在变量 Timestamp 中。
<br>Clipboard := Timestamp . " "：将格式化后的时间戳复制到剪贴板，并在末尾添加一个空格。
<br>Send ^v：发送粘贴命令，将剪贴板内容粘贴到当前光标位置。
<br>Sleep, 50：等待50毫秒，确保粘贴操作完成。
<br>StringReplace, Clipboard, Clipboard, :, :, All：确保剪贴板中的冒号是半角。
<br>将上述脚本保存为 .ahk 文件并运行，您就可以通过键入 @@ 来获取并插入格式化的日期时间戳了。]]></description><link>项目\ahk学习\字符连接.html</link><guid isPermaLink="false">项目/ahk学习/字符连接.md</guid><pubDate>Tue, 08 Oct 2024 14:35:41 GMT</pubDate></item><item><title><![CDATA[<strong>Cherry</strong>]]></title><description><![CDATA[ 
 <br><br>在AutoHotkey (AHK) 中，Run 命令主要用于启动外部程序或打开文件和URL。它确实主要用于处理HTTP和HTTPS链接，因为这些是Web的标准协议。然而，对于第三方链接（例如自定义协议或本地应用程序链接），您可以使用不同的方法来处理。<br><br>如果您需要处理自定义协议（例如 myapp:// 或 customprotocol://），Run 命令通常也可以处理这些情况，前提是系统已经注册了这些协议的处理程序。例如：<br>Run, myapp://open?param=value
复制<br>这将会启动注册了 myapp:// 协议的应用程序，并传递参数 param=value。<br><br>对于更复杂的场景，您可能需要使用 ShellExecute 函数，它是Windows API的一部分，提供了更强大的功能来处理各种URL和文件类型。以下是一个示例：<br>DllCall("shell32\ShellExecute", "ptr", 0, "str", "open", "str", "customprotocol://open?param=value", "str", "", "str", "", "int", 1)
复制<br>在这个示例中：<br>
<br>ptr, 0：指向父窗口的句柄。可以使用 0 表示没有父窗口。
<br>str, "open"：操作类型，通常是 "open"。
<br>str, "customprotocol://open?param=value"：要处理的URL或文件路径。
<br>str, ""：工作目录，留空表示当前目录。
<br>str, ""：参数列表，留空表示没有参数。
<br>int, 1：显示方式，1 表示正常显示。
<br><br>如果链接指向的是本地应用程序（例如 steam:// 或 spotify://），Run 命令通常也可以处理这些情况。例如：<br>Run, steam://open/main
复制<br>这将会启动Steam应用程序。<br><br>
<br>对于标准HTTP/HTTPS链接，使用 Run 命令。
<br>对于自定义协议或本地应用程序链接，Run 命令通常也能处理。
<br>对于更复杂的场景，可以使用 ShellExecute 函数。
<br>希望这些方法能帮助您处理各种类型的链接。如果您有具体的链接示例或遇到具体问题，请提供更多信息以便进一步帮助。<br><br>原来问题出现在这里<br><br>Run,obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true
Error at line 1.
Line Text:
obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true
Error: This parameter contains a variable name missing its ending percent sign
The program will exit.
复制<br><br>您遇到的错误是由于URL中包含了一个未正确编码的字符。具体来说，daily=true 中的 \= 字符在AHK中被解释为变量的一部分，而缺少结束的百分号 %。<br>为了避免这种情况，您可以使用 Run 命令的另一种形式，即使用 % 包裹参数，以明确指定这是一个字符串而不是变量。<br>以下是修正后的脚本示例：<br>Run, % "obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true"
复制<br>[tab]<br><br>
<br>打开脚本文件：在文本编辑器中打开您的AHK脚本文件。
<br>修改Run命令：将 Run, obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true 修改为 Run, % "obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true"。
<br>保存文件：保存修改后的脚本文件。
<br><br>假设您的完整脚本如下：<br>Run, % "obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;daily=true"
复制<br><br>保存并运行修改后的脚本，确保它可以正常工作。如果仍然遇到问题，请检查URL的完整性和正确性，确保没有遗漏或错误的字符。<br><br>结果是成功运行脚本。也因此可以通过ahk使用Obsidian-uri的打开日历功能。]]></description><link>项目\ahk学习\ahk处理第三方链接.html</link><guid isPermaLink="false">项目/ahk学习/AHK处理第三方链接.md</guid><pubDate>Tue, 08 Oct 2024 14:48:45 GMT</pubDate></item><item><title><![CDATA[总览]]></title><description><![CDATA[ 
 <br>使用ahk做一个小而简单的计时器，试图采用<a class="internal-link" data-href="记录/DailyNotes/2024年10月9日.md#渐进式提问" href="记录\dailynotes\2024年10月9日.html#渐进式提问" target="_self" rel="noopener">渐进式提问</a>的方法。<br><br><br>计时器的逻辑不难，输入时间，开始计时，然后停止的时候发出弹窗。不过和弹窗相关的GUI部分可以优化一下。<br>逻辑输入InputBox存入变量，Sleep计时到点结束，发出弹窗GUI输入窗口，计时窗口输入用InputBox简单代替，而计时窗口试图使用液柱到点结束
    
      
        
        
      
    
  <br>下一阶段的内容是可以重复运行的定时器，涉及到循环的内容，还有一些可以优化的方式：<br>重复定时（循环）增加暂停功能（暂停和继续和退出）增加退出功能
    
      
        
        
      
    
  <br>
主要就是GUI的学习了，逻辑其实还好，可以参考已有的代码了
<br>]]></description><link>项目\ahk学习\ahk计时器.html</link><guid isPermaLink="false">项目/ahk学习/AHK计时器.md</guid><pubDate>Sun, 13 Oct 2024 00:18:36 GMT</pubDate></item><item><title><![CDATA[依赖关系]]></title><description><![CDATA[<a class="tag" href="?query=tag:AHK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AHK</a> 
 <br>
<br>AHK实现视频截图 <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener">#AHK</a> ✅ 2024-10-12
<br><br><br><br>
<br>使用uri的内置命令，获取属性添加和文件的元数据<br>
以本文件为例：obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;filepath=ahk%E5%AD%A6%E4%B9%A0%2FAHK%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%88%AA%E5%9B%BE.md
<br>执行命令应该是：`obsidian://adv-uri?vault=%E4%B8%BB%E4%BB%93%E5%BA%93&amp;commandid=media-extended%3Asave-screenshot
<br><br>一般是询问gpt 后得到的解决方案<br>
<br><a data-href="并排和可以拖动" href="项目\ahk学习\并排和可以拖动.html" class="internal-link" target="_self" rel="noopener">并排和可以拖动</a>
]]></description><link>项目\ahk学习\ahk实现视频截图.html</link><guid isPermaLink="false">项目/ahk学习/AHK实现视频截图.md</guid><pubDate>Sat, 12 Oct 2024 11:35:38 GMT</pubDate></item><item><title><![CDATA[AHK小型清单]]></title><description><![CDATA[<a class="tag" href="?query=tag:AHK" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#AHK</a> 
 <br>清单的几个元素，输入，存储，点击删除。<br>
<br>AHK小型清单 <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener">#AHK</a> 
]]></description><link>项目\ahk学习\ahk小型清单.html</link><guid isPermaLink="false">项目/ahk学习/AHK小型清单.md</guid><pubDate>Sun, 13 Oct 2024 00:52:22 GMT</pubDate></item><item><title><![CDATA[ahk学习]]></title><description><![CDATA[ 
 <br>本机下载的语法是v2.0的，因此语法相较于之前有些修改，反正我都没学过是没有啥负担的，不过对于GPT和之后来说，肯定就有变化。<br>
这里是官方的中文文档：<a data-tooltip-position="top" aria-label="https://wyagd001.github.io/v2/docs/Tutorial.htm" rel="noopener" class="external-link" href="https://wyagd001.github.io/v2/docs/Tutorial.htm" target="_blank">初学者向导 | AutoHotkey v2 (wyagd001.github.io)</a><br>
也许不是官方的。
<br>本库是AHK学习相关。<br><br><br><br>
<br>打开一组特定的网址（用edge，这个应该比较简单）
<br>Run 指定可以大概网址<br>
<br>可以运行Obsidian-uri 指令么？
<br>至少简单的Run是不行的：<br>
请注意，Run命令可以处理包含http://或https://的完整URL，所以即使您的前一个网址没有http://协议前缀，Run命令也会默认尝试使用http://打开它。如果想要确保使用https://，最好明确写出协议前缀。
<br><br>
<br>搞类似vscode 的ctrl+k/ctrl+o 的效果（其实这个已经有前端案例了，不过我认为ahk会快一些） <a href=".?query=tag:灵感" class="tag" target="_blank" rel="noopener" data-tag-name="#灵感">#灵感</a> <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener" data-tag-name="#AHK">#AHK</a> ❌ 2024-10-09
<br>使用@@语法快速插入当时时刻
<br><a data-href="字符连接" href="项目\ahk学习\字符连接.html" class="internal-link" target="_self" rel="noopener">字符连接</a>
<br>使用剪贴板的方式，成功将半角的冒号打印出来，之前都是会根据输入法的变化而变化: <a data-tooltip-position="top" aria-label="file:%5C%5CE:%5CBox%5CProjects%5Cahk@@-date_time.ahk" rel="noopener" class="external-link" href="file:\\E:\\Box\Projects\ahk@@-date_time.ahk" target="_blank">ahk文件</a>

<br><a href=".?query=tag:目录" class="tag" target="_blank" rel="noopener" data-tag-name="#目录">#目录</a> <a data-tooltip-position="top" aria-label="file:%5C%5CE:%5CBox%5CProjects%5Cahk" rel="noopener" class="external-link" href="file:\\E:\\Box\Projects\ahk" target="_blank">ahk项目目录</a> ✅ 2024-10-08
<br>实现浏览器访问Obsidian-uri链接的方式对文本进行简单的访问
<br><br><br>AHK计时器的暂停和继续 <a class="internal-link" data-href="../../项目/ahk学习/AHK计时器.md" href="项目\ahk学习\ahk计时器.html" target="_self" rel="noopener">AHK计时器</a> <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener" data-tag-name="#AHK">#AHK</a> (<a rel="noopener" target="_self" class="internal-link">2024年10月9日 &gt; 安排</a>)<a class="tasks-edit" title="Edit task" href="about:blank#"></a><br>AHK小型清单 <a href=".?query=tag:AHK" class="tag" target="_blank" rel="noopener">#AHK</a>]]></description><link>项目\ahk学习\ahk学习.html</link><guid isPermaLink="false">项目/ahk学习/ahk学习.md</guid><pubDate>Sun, 13 Oct 2024 00:50:24 GMT</pubDate></item><item><title><![CDATA[DLLCALL的HOOK函数]]></title><description><![CDATA[ 
 <br>DllCall 和 OnMessage 配合使用是为了处理特定窗口消息，从而实现窗口的拖动功能。具体来说，这些代码的功能如下：<br><br>这行代码的作用是注册当前窗口，使其能够接收Shell Hook（外壳钩子）消息。Shell Hook是一种Windows机制，允许应用程序接收系统级事件的通知。通过注册Shell Hook，你可以让窗口接收一些额外的系统消息，从而实现更多定制功能。<br><br>这两行代码的作用是设置自定义的消息处理函数来处理特定的Windows消息。具体来说：<br>
<br>0x004A 是 WM_COPYDATA 消息的ID。这个消息用于在进程之间传递数据。
<br>0x004E 是 WM_NOTIFY 消息的ID。这个消息用于在控件和其父窗口之间传递通知消息。
<br>通过 OnMessage 函数，你可以指定一个自定义的回调函数来处理这些消息。在这个例子中，回调函数是 Receive_WM_COPYDATA。<br><br>这个函数的定义如下：<br>; 定义 WM_COPYDATA 消息处理函数
Receive_WM_COPYDATA(wParam, lParam) {
    return DllCall("DefWindowProc", "Ptr", wParam, "UInt", 0x004A, "Ptr", lParam, "Ptr")
}
复制<br>Receive_WM_COPYDATA 函数是一个自定义的消息处理函数，用于处理 WM_COPYDATA 和 WM_NOTIFY 消息。具体来说，这个函数调用了 DefWindowProc 函数，这是Windows API中的一个默认窗口过程函数，用于处理未被应用程序明确处理的消息。<br>通过调用 DefWindowProc，你可以确保未被自定义处理的消息仍然能够被正常处理，从而避免窗口失去响应。<br><br>这些代码的主要目的是使窗口可拖动。通过注册Shell Hook和处理特定的窗口消息，你可以实现窗口的拖动功能，而无需依赖传统的标题栏。这样可以让你的窗口在视觉上更加简洁，同时保持功能完整。<br>如果你有更多问题或需要进一步的帮助，请随时提问！]]></description><link>项目\ahk学习\dllcall的hook函数.html</link><guid isPermaLink="false">项目/ahk学习/DLLCALL的HOOK函数.md</guid><pubDate>Sat, 12 Oct 2024 11:28:49 GMT</pubDate></item><item><title><![CDATA[mykeymap2.0]]></title><description><![CDATA[ 
 <br>这是大佬已经写好一个ahk写的快捷方式的应用，核心以Capslock作为出发按键（也可以其他的），执行一系列的快速指令操作，我把简介放在这里：<a data-tooltip-position="top" aria-label="https://xianyukang.com/MyKeymap.html" rel="noopener" class="external-link" href="https://xianyukang.com/MyKeymap.html" target="_blank">MyKeymap 简介 | 咸鱼阿康 (xianyukang.com)</a><br>目前在用，比较常用的是鼠标右键+滚轮上下进行软件内标签页的切换(edge或者Obsidian)，实际上是快捷键Ctrl+Tab或者Ctrl+Shift+Tab的组合，这个可以定制的软件一定程度上削减了我学ahk的想法，不过鉴于最开始学ahk也就是想看看这是做什么的，所以其实也无关紧要来着。ahk的前景是很广阔的，就是要深入了解windows的各种api，和aardio的性质有点类似。]]></description><link>项目\ahk学习\mykeymap2.0.html</link><guid isPermaLink="false">项目/ahk学习/mykeymap2.0.md</guid><pubDate>Wed, 09 Oct 2024 12:11:22 GMT</pubDate></item><item><title><![CDATA[Vscode文件夹_等待按键输入]]></title><description><![CDATA[ 
 <br>在 AutoHotkey 中，可以通过定义一系列的按键序列来模拟 VSCode 中的复合按键操作，比如先按 Ctrl + K 再按 Ctrl + O 来打开某个文件夹。为了实现这一点，你可以使用 Hotkey 和 KeyWait 命令来检测按键序列，并在满足条件时执行相应的操作。<br>以下是一个示例脚本，展示了如何实现这个功能：<br>; 定义第一个热键：Ctrl + K
^k::
    ; 等待下一个按键
    KeyWait, k, T0.5  ; 等待 0.5 秒，如果超时则取消
    if ErrorLevel  ; 如果等待超时
    {
        Send, ^k  ; 直接发送 Ctrl + K
        return
    }
    
    ; 等待下一个按键 Ctrl + O
    Input, key, L1 T0.5, {Ctrl down}{Ctrl up}{LWin down}{LWin up}{RWin down}{RWin up}{Alt down}{Alt up}  ; 只接受一个字符，且不接受修饰键
    if (key = "o")
    {
        Send, {Ctrl down}o{Ctrl up}  ; 发送 Ctrl + O
        Run, C:\Path\To\Your\Folder  ; 打开指定的文件夹
    }
    else
    {
        Send, ^k  ; 发送 Ctrl + K
        Send, %key%  ; 发送按下的下一个键
    }
return
复制<br>在这个脚本中：<br>
<br>^k:: 定义了一个热键，表示当按下 Ctrl + K 时，执行特定的操作。
<br>KeyWait, k, T0.5 用于等待下一个按键，超时时间为 0.5 秒。如果超时，则直接发送 Ctrl + K。
<br>Input, key, L1 T0.5, ... 用于检测下一个按键是否为 o，且不接受其他修饰键。
<br>如果检测到下一个按键是 o，则发送 Ctrl + O，并通过 Run 命令打开指定的文件夹。
<br>如果检测到的按键不是 o，则发送 Ctrl + K，并继续发送检测到的按键。
<br>请注意，C:\Path\To\Your\Folder 需要替换为你实际想要打开的文件夹路径。<br>这种方式可以模拟 VSCode 中的复合按键操作，但需要确保按键序列的检测时间和顺序符合你的预期。你可以根据自己的需求调整等待时间和按键序列。]]></description><link>项目\ahk学习\vscode文件夹_等待按键输入.html</link><guid isPermaLink="false">项目/ahk学习/Vscode文件夹_等待按键输入.md</guid><pubDate>Sat, 12 Oct 2024 09:31:36 GMT</pubDate></item><item><title><![CDATA[搭建Vercel的静态网页]]></title><description><![CDATA[ 
 <br>
<br>用vecel+ webpageexport插件搭建一个静态网页，服务器和域名再说 📅2024-10-13
]]></description><link>项目\搭建vercel的静态网页.html</link><guid isPermaLink="false">项目/搭建Vercel的静态网页.md</guid><pubDate>Sun, 13 Oct 2024 01:12:15 GMT</pubDate></item><item><title><![CDATA[多路复用器]]></title><description><![CDATA[ 
 <br><br>module mux4to1 (
    input [1:0] sel,  // 2-bit selection signal
    input [3:0] in,   // 4 inputs
    output out        // Output
);

assign out = (sel == 2'b00) ? in[0] :
             (sel == 2'b01) ? in[1] :
             (sel == 2'b10) ? in[2] :
             (sel == 2'b11) ? in[3] : 1'bx;  // Default case

endmodule
复制<br><br>module mux4to1 (
    input [1:0] sel,  // 2-bit selection signal
    input [3:0] in,   // 4 inputs
    output reg out    // Output
);

always @(*) begin
    case (sel)
        2'b00: out = in[0];
        2'b01: out = in[1];
        2'b10: out = in[2];
        2'b11: out = in[3];
        default: out = 1'bx;  // Default case
    endcase
end

endmodule

复制<br>
<br><a data-href="always和assign的区别" href="项目\always和assign的区别.html" class="internal-link" target="_self" rel="noopener">always和assign的区别</a>
]]></description><link>项目\多路复用器.html</link><guid isPermaLink="false">项目/多路复用器.md</guid><pubDate>Sun, 13 Oct 2024 03:24:04 GMT</pubDate></item><item><title><![CDATA[李宏毅机器学习课程]]></title><description><![CDATA[<a class="tag" href="?query=tag:深度学习" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#深度学习</a> <a class="tag" href="?query=tag:学习" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#学习</a> <a class="tag" href="?query=tag:项目" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#项目</a> 
 <br>
<br>李宏毅机器学习课程 <a rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1Wv411h7kN?t=4.9" target="_blank">https://www.bilibili.com/video/BV1Wv411h7kN?t=4.9</a> <a href=".?query=tag:深度学习" class="tag" target="_blank" rel="noopener">#深度学习</a> <a href=".?query=tag:学习" class="tag" target="_blank" rel="noopener">#学习</a> <a href=".?query=tag:项目" class="tag" target="_blank" rel="noopener">#项目</a> 📅 2024-12-1
]]></description><link>项目\李宏毅机器学习课程.html</link><guid isPermaLink="false">项目/李宏毅机器学习课程.md</guid><pubDate>Sun, 13 Oct 2024 00:53:00 GMT</pubDate></item><item><title><![CDATA[论文Attention is all you need]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://marker.dotalk.cn/#/?nx=HM29FB5&amp;vs=1" rel="noopener" class="external-link" href="https://marker.dotalk.cn/#/?nx=HM29FB5&amp;vs=1" target="_blank">五彩链接</a><br>
<br>端到端的内存网络基于循环注意力机制而不是序列对齐的循环，已经在简单的语言问题回答和语言建模任务中表现出良好的性能[34]。
<br>We call our particular attention "Scaled Dot-Product Attention" (Figure 2).
<br>缩放点积注意力”<br>
<img src="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/12O-9dkBj.xQf.bx.-L_H0S__4mE4IBdu-" referrerpolicy="no-referrer"><br>
- 自注意力计算函数<br>
<img src="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/12vsE0Y.63-_IQC-cxCfg.D-a6rr7CAlWd" referrerpolicy="no-referrer">
<br>由于每个头部<a data-footref="1" href="about:blank#fn-1-f5bc0ac972a01729" class="footnote-link" target="_self" rel="noopener">[1]</a>的维度降低，总的计算成本与全维度单个头部的注意力相似。
<br>编码器包含自我注意力层。在自我注意力层中，所有键、值和查询都来自同一位置，在这种情况下，编码器中前一层的输出。编码器中的每个位置可以关注编码器前一层的所有位置。
<br>We need to prevent leftward information flow in the decoder to preserve the auto-regressive property.
<br>位置编码有许多选择，包括学习和固定[9]。

<br>词嵌入的逻辑


<br>位置编码的每个维度对应一个正弦函数
<br>Learning long-range dependencies is a key challenge in many sequence transduction tasks
<br>The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn long-range dependencies [12].<br>
<img src="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/12TuCSlgFLHhrYf4Ig290xdtwh7pJ7Vq5J" referrerpolicy="no-referrer">
<br>many appear to exhibit behavior related to the syntactic and semantic structure of the sentences.
<br>During training, we employed label smoothing of value
<br>as the model learns to be more unsure, but improves accuracy and BLEU score.
<br>我们通过将训练时间、使用的 GPU 数量以及对每块 GPU 的单精度浮点运算持续能力的估计相乘，来估算训练一个模型所需的浮点运算次数。
<br>我们进一步观察到，如预期的那样，更大的模型表现更好，而 dropout 在防止过拟合方面非常有帮助。在行（E）中，我们将我们的正弦余弦位置编码替换为学习到的位置嵌入[9]，并观察到与基本模型几乎相同的结果。
<br>我们的结果如表 4 所示，尽管我们的模型没有进行任务特定的调整，但其表现令人惊讶地好，比之前所有报告的模型（除了递归神经网络语法[8]）都得到了更好的结果。
<br>与 RNN 序列到序列模型[37]相反，Transformer 在仅使用 4 万句 WSJ 训练集进行训练时，就超过了伯克利解析器[29]
<br>In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.
<br>在本工作中，我们介绍了 Transformer，这是第一个完全基于注意力的序列转换模型，它用多头自注意力替换了编码器-解码器架构中常用的循环层。
<br>The code we used to train and evaluate our models is available at <a rel="noopener" class="external-link" href="https://github.com/tensorflow/tensor2tensor" target="_blank">https://github.com/tensorflow/tensor2tensor</a>.
<br><br>2024-10-12 11:50<br>
主要对大模型的自注意力机制有了一个浅显的了解，只看论文不能体会Transformer的一些特性，而且很多原理和基础知识都还不清楚。因此看得也比较粗浅。晚上再看的时候可以针对一些东西制定任务安排。<br><br><br>
<br>
<br>这里提到的是多头注意力的机制<a href="about:blank#fnref-1-f5bc0ac972a01729" class="footnote-backref footnote-link" target="_self" rel="noopener">↩︎</a>
]]></description><link>项目\论文attention-is-all-you-need.html</link><guid isPermaLink="false">项目/论文Attention is all you need.md</guid><pubDate>Sat, 12 Oct 2024 11:42:57 GMT</pubDate><enclosure url="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/12O-9dkBj.xQf.bx.-L_H0S__4mE4IBdu-" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/12O-9dkBj.xQf.bx.-L_H0S__4mE4IBdu-&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[认识Chisel]]></title><description><![CDATA[ 
 <br>
<br>认识Chisel 📅2024-10-14
]]></description><link>项目\认识chisel.html</link><guid isPermaLink="false">项目/认识Chisel.md</guid><pubDate>Sun, 13 Oct 2024 00:52:43 GMT</pubDate></item><item><title><![CDATA[正文]]></title><description><![CDATA[<a class="tag" href="?query=tag:Transformer" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transformer</a> <a class="tag" href="?query=tag:神经网络" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#神经网络</a> 
 <br>网页地址：<a data-tooltip-position="top" aria-label="https://www.ruanyifeng.com/blog/2017/07/neural-network.html" rel="noopener" class="external-link" href="https://www.ruanyifeng.com/blog/2017/07/neural-network.html" target="_blank">神经网络入门 - 阮一峰的网络日志 (ruanyifeng.com)</a><br>
<br>这里是文中提及的开源入门书籍第一章：<a data-tooltip-position="top" aria-label="http://neuralnetworksanddeeplearning.com/chap1.html" rel="noopener" class="external-link" href="http://neuralnetworksanddeeplearning.com/chap1.html" target="_blank">Neural networks and deep learning</a> <a href=".?query=tag:Transformer" class="tag" target="_blank" rel="noopener">#Transformer</a> <a href=".?query=tag:神经网络" class="tag" target="_blank" rel="noopener">#神经网络</a> 📅 2024-10-14 ❌ 2024-10-13
<br><br>东西比较少，确实是介绍内容<br><br><a data-tooltip-position="top" aria-label="https://marker.dotalk.cn/#/?nx=HM29BE5&amp;vs=1" rel="noopener" class="external-link" href="https://marker.dotalk.cn/#/?nx=HM29BE5&amp;vs=1" target="_blank">五彩链接</a><br>
<br>人工智能的底层模型是"神经网络"（neural network）。许多复杂的应用（比如模式识别、自动控制）和高级模型（比如深度学习）都基于它。学习人工智能，一定是从它开始。<br>
<img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071201.jpg" referrerpolicy="no-referrer">
<br>前两天，我读到 Michael Nielsen 的开源教材《神经网络与深度学习》（Neural Networks and Deep Learning），意外发现里面的解释非常好懂。下面，我就按照这本书，介绍什么是神经网络。
<br>单个的感知器构成了一个简单的决策模型，已经可以拿来用了。真实世界中，实际的决策模型则要复杂得多，是由多个感知器组成的多层网络。
<br>定义运算 w⋅x = ∑ wx，即 w 和 x 的点运算，等于因素与权重的乘积之和
<br>定义 b 等于负的阈值 b = -threshold
<br>这种方法就是试错法。其他参数都不变，w（或b）的微小变动，记作Δw（或Δb），然后观察输出有什么变化。不断重复这个过程，直至得到对应最精确输出的那组w和b，就是我们要的值。这个过程称为模型的训练。<br>
- 模型的训练<br>
<img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071208.png" referrerpolicy="no-referrer">
<br>原来的输出曲线是下面这样。
<br>sigmoid：罗季斯提函数<br>
<img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071209.png" referrerpolicy="no-referrer">
<br><img src="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071210.png" referrerpolicy="no-referrer"><br>
<br>即Δσ和Δw和Δb之间是线性关系，变化率是偏导数。这就有利于精确推算出w和b的值了。

<br>数学的东西要捡起来了。。


]]></description><link>项目\阮一峰神经网络（网页）.html</link><guid isPermaLink="false">项目/阮一峰神经网络（网页）.md</guid><pubDate>Sun, 13 Oct 2024 04:21:10 GMT</pubDate><enclosure url="https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071201.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://www.ruanyifeng.com/blogimg/asset/2017/bg2017071201.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[本文件夹]]></title><description><![CDATA[ 
 <br>dufs是一个简单的文件服务器，可以以http协议访问本地的文件，很多的软件可以因此进行调试。<br><br><img src="项目\assets\pasted-image-20241013082629.png"><br><br>dufs -A xxx(目标文件夹路径)<br>Dufs is a distinctive utility file server - https://github.com/sigoden/dufs

Usage: dufs [OPTIONS] [serve-path]

Arguments:
  [serve-path]  Specific path to serve [default: .]

Options:
  -c, --config &lt;file&gt;        Specify configuration file
  -b, --bind &lt;addrs&gt;         Specify bind address or unix socket
  -p, --port &lt;port&gt;          Specify port to listen on [default: 5000]
      --path-prefix &lt;path&gt;   Specify a path prefix
      --hidden &lt;value&gt;       Hide paths from directory listings, e.g. tmp,*.log,*.lock
  -a, --auth &lt;rules&gt;         Add auth roles, e.g. user:pass@/dir1:rw,/dir2
  -A, --allow-all            Allow all operations
      --allow-upload         Allow upload files/folders
      --allow-delete         Allow delete files/folders
      --allow-search         Allow search files/folders
      --allow-symlink        Allow symlink to files/folders outside root directory
      --allow-archive        Allow zip archive generation
      --enable-cors          Enable CORS, sets `Access-Control-Allow-Origin: *`
      --render-index         Serve index.html when requesting a directory, returns 404 if not found index.html
      --render-try-index     Serve index.html when requesting a directory, returns directory listing if not found index.html
      --render-spa           Serve SPA(Single Page Application)
      --assets &lt;path&gt;        Set the path to the assets directory for overriding the built-in assets
      --log-format &lt;format&gt;  Customize http log format
      --log-file &lt;file&gt;      Specify the file to save logs to, other than stdout/stderr
      --compress &lt;level&gt;     Set zip compress level [default: low] [possible values: none, low, medium, high]
      --completions &lt;shell&gt;  Print shell completion script for &lt;shell&gt; [possible values: bash, elvish, fish, powershell, zsh]
      --tls-cert &lt;path&gt;      Path to an SSL/TLS certificate to serve with HTTPS
      --tls-key &lt;path&gt;       Path to the SSL/TLS certificate's private key
  -h, --help                 Print help
  -V, --version              Print version
复制<br><br><img src="项目\assets\pasted-image-20241013084147.png">]]></description><link>项目\使用dufs.html</link><guid isPermaLink="false">项目/使用dufs.md</guid><pubDate>Sun, 13 Oct 2024 00:42:00 GMT</pubDate><enclosure url="项目\assets\pasted-image-20241013082629.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;项目\assets\pasted-image-20241013082629.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[宿舍NFC门锁]]></title><description><![CDATA[ 
 <br>照着教程来做就好了，下面是大致的步骤<br>
<br>准备材料

<br>荣耀充电宝2代（支持长时间微电流充电的充电宝）
<br>arduino平台单片机（不用焊接，比较方便）
<br>mg90s舵机（力量可以达到14牛顿足以拉开门锁）
<br>rc522模块（比较常用的模块，51平台，stm平台，arduino平台都通用）
<br>线材（连接主板和舵机）
<br>热熔胶+胶枪


<br>在Ardunio中烧录
<br>进行连接
]]></description><link>项目\宿舍nfc门锁.html</link><guid isPermaLink="false">项目/宿舍NFC门锁.md</guid><pubDate>Sat, 12 Oct 2024 15:10:34 GMT</pubDate></item><item><title><![CDATA[稀疏自解码器]]></title><description><![CDATA[ 
 <br>稀疏自解码器（Sparse Auto-Encoder）是一种神经网络架构，它是自编码器（Autoencoder）的一个变体。自编码器是一种用于学习数据表达形式的无监督学习算法，它试图学习如何从原始数据中提取有用的特征。稀疏自解码器增加了所谓“稀疏性”的要求，即它在学习过程中试图满足某些神经元（节点）只在原始输入数据的特定部分上活动的特性。<br>以下是一些关于稀疏自解码器的主要特点：<br>
<br>
结构：

<br>稀疏自解码器通常具有与输入层相同的尺寸或稍微小一些的编码层，然后再对数据进行解码以重构原始输入。
<br>编码层和输出层都包含多个神经元。


<br>
稀疏性：

<br>稀疏性可以定义为编码层中大部分神经元激活频率很低，而一小部分神经元经常被激活。
<br>这种特性要求在训练过程中实施正则化或稀疏性约束。


<br>
约束：

<br>稀疏自解码器通过应用稀疏性正则化（如L1正则化）来鼓励稀疏性。L1正则化在神经元的权重上施加惩罚，使得权重接近零，从而减少激活神经元的数量。
<br>另一种方法是在损失函数中添加一个项，鼓励尽可能多的神经元不激活（稀疏项）。


<br>
应用：

<br>稀疏自解码器可以用于特征提取，它可以学习到数据压缩的表示，同时保留重要特征。
<br>它还可以用于降维，如在高维数据集中识别主要特征。
<br>还有其他应用，如异常检测或噪声去除。


<br>
训练：

<br>稀疏自解码器的神经网络通过梯度下降或其他优化算法进行训练，以最小化重构误差。
<br>由于L1正则化的引入，训练可能会变得稍微复杂，因为模型必须同时优化数据的重构和权重的稀疏性。


<br>稀疏自解码器在处理高维数据时特别有用，因为它可以帮助网络学习到关于数据的更简洁和更具代表性的表示。通过学习数据中的稀疏模式，这种架构能够更有效地捕获数据中的关键信息。]]></description><link>项目\稀疏自解码器.html</link><guid isPermaLink="false">项目/稀疏自解码器.md</guid><pubDate>Sun, 13 Oct 2024 00:45:59 GMT</pubDate></item><item><title><![CDATA[线性代数的本质视频]]></title><description><![CDATA[ 
 ]]></description><link>项目\线性代数的本质视频.html</link><guid isPermaLink="false">项目/线性代数的本质视频.md</guid><pubDate>Fri, 11 Oct 2024 07:07:24 GMT</pubDate></item><item><title><![CDATA[学习Verilog语法]]></title><description><![CDATA[ 
 <br>冰冻三尺非一日之寒，在没有向项目驱动的前提下，无法很好的学习一个语言的精髓。而且Verilog是偏向硬件的开发，手头山没有设备不好做调试的效果。<br>不过既然有任务需求，那还是要看看的，也是当了解和落实。<br>
<br><a data-tooltip-position="top" aria-label="https://hdlbits.01xz.net/wiki/Zero" rel="noopener" class="external-link" href="https://hdlbits.01xz.net/wiki/Zero" target="_blank">Zero - HDLBits (01xz.net)</a> 老师提供的网址是手把手教你学怎么写Verilog的，那挺好，完全可以日常学习玩玩；结合实践才是最强的
<br><a data-href="reg和wire的区别" href="项目\reg和wire的区别.html" class="internal-link" target="_self" rel="noopener">reg和wire的区别</a>：寄存器和集线器的区别
<br>继续，网页的学习 📅 2024-10-13 ✅ 2024-10-13
<br><a data-href="多路复用器" href="项目\多路复用器.html" class="internal-link" target="_self" rel="noopener">多路复用器</a>
]]></description><link>项目\学习verilog语法.html</link><guid isPermaLink="false">项目/学习Verilog语法.md</guid><pubDate>Sun, 13 Oct 2024 04:20:17 GMT</pubDate></item><item><title><![CDATA[自注意力机制]]></title><description><![CDATA[ 
 <br><img src="项目\assets\pasted-image-20241011203042.png"><br>自注意力机制（Self-Attention Mechanism）是深度学习领域中一种非常重要的机制，尤其在自然语言处理（NLP）和序列模型中应用广泛。自注意力机制允许模型在处理序列数据时，自动地专注于输入序列中与当前位置相关的有用信息，无论这些信息出现在序列的哪个位置。<br><br>自注意力机制的核心思想是：对于一个序列中的每一个元素（如词向量），模型能够根据这个序列中的所有其他元素（或部分元素）来为当前元素动态地计算一个权重。这样，每个元素都有自己的重要性权重，这个权重是根据它在上下文中的表现来确定的。<br><br>自注意力机制通常包含以下几个组件：<br>
<br>
Query（查询）、Key（键）和Value（值）：对于一个给定的序列，我们将每个元素转换成三个向量：查询向量（Q）、键向量（K）和值向量（V）。

<br>
缩放点积注意力：对于序列中的每个元素，计算其与其他元素之间的注意力分数，通常通过点积方式进行计算，并乘以一个缩放因子（因为输入的向量可能在很大的数值范围）。

<br>
Softmax：使用Softmax函数对注意力分数进行归一化，得到一个概率分布。

<br>
加权求和：根据Softmax得到的概率分布，将所有值向量按比例加权求和，得到一个加权向量。

<br><br>假设我们有序列 ( X = [x_1, x_2, ..., x_n] )，将每个元素 ( x_i ) 通过变换 ( W_Q, W_K, W_V ) 转换为查询向量 ( Q_i )、键向量 ( K_i ) 和值向量 ( V_i )，自注意力机制的计算过程可以表示如下：<br>[ \text{Attention}(Q, K, V) = \text{softmax}(\frac{QK^T}{\sqrt{d_k}})V ]<br>其中 ( d_k ) 是每个向量维度，( QK^T ) 是查询和键的点积，Softmax之后得到的每个 ( V ) 的加权和即为当前查询的表示。<br><br>自注意力机制被广泛应用于Transformers模型中，这种模型结构在处理自然语言处理任务时，如机器翻译、文本摘要、问答系统等，都取得了显著的成果。自注意力机制使得模型能够捕捉长距离的依赖关系，并有效地处理并行处理信息。<br><br>自注意力机制是一种强大的序列建模工具，它通过动态关注序列中的相关信息来提高模型的表示能力，是现代深度学习模型中的一个关键组成部分。]]></description><link>项目\自注意力机制.html</link><guid isPermaLink="false">项目/自注意力机制.md</guid><pubDate>Sat, 12 Oct 2024 00:29:33 GMT</pubDate><enclosure url="项目\assets\pasted-image-20241011203042.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;项目\assets\pasted-image-20241011203042.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[always和assign的区别]]></title><description><![CDATA[ 
 <br>在Verilog中，always块用于描述组合逻辑或时序逻辑的行为。当使用always块时，变量的赋值不需要使用assign关键字，这是因为always块本身定义了一个过程，会在敏感列表中的信号发生变化时执行块内的语句。<br><br>
<br>敏感列表：always块有一个敏感列表（sensitivity list），列出了所有会触发块内语句执行的信号。对于组合逻辑，通常使用always @(*)，表示对块内所有变量的变化敏感。
<br>过程赋值：在 always 块内部，使用 \=（阻塞赋值）或 &lt;=（非阻塞赋值）进行变量赋值。这些赋值语句定义了在敏感列表触发时变量的新值。
<br><br>
<br>连续赋值：assign语句用于连续赋值，即在右侧信号变化时，左侧信号会立即更新。
<br>适用于连线：assign 语句通常用于描述连线（wires）之间的直接连接，而不是过程（如 always 块）内部的赋值。
<br>也就是说，assign本体是和always平级的操作，因此在always内部赋值的时候不需要使用assign进行变量赋值。]]></description><link>项目\always和assign的区别.html</link><guid isPermaLink="false">项目/always和assign的区别.md</guid><pubDate>Sun, 13 Oct 2024 03:25:29 GMT</pubDate></item><item><title><![CDATA[cs231n：手撕神经网络 ]]></title><description><![CDATA[<a class="tag" href="?query=tag:深度学习" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#深度学习</a> <a class="tag" href="?query=tag:项目" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#项目</a> 
 <br>
<br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1nJ411z7fe/?buvid=YE43F3E12616CF964F159FA299357AFF6C64&amp;from_spmid=search.search-result.0.0&amp;is_story_h5=false&amp;mid=wl%2BP7KvizniLi8eZ%2FCkDWA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=616FAB7E-96F1-4A9C-9FF5-75E85E96D92A&amp;share_source=QQ&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1728642415&amp;unique_k=Q8HvEE4&amp;up_id=483359852" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1nJ411z7fe/?buvid=YE43F3E12616CF964F159FA299357AFF6C64&amp;from_spmid=search.search-result.0.0&amp;is_story_h5=false&amp;mid=wl%2BP7KvizniLi8eZ%2FCkDWA%3D%3D&amp;p=1&amp;plat_id=116&amp;share_from=ugc&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=616FAB7E-96F1-4A9C-9FF5-75E85E96D92A&amp;share_source=QQ&amp;share_tag=s_i&amp;spmid=united.player-video-detail.0.0&amp;timestamp=1728642415&amp;unique_k=Q8HvEE4&amp;up_id=483359852" target="_blank">手撕深度学习</a> <a href=".?query=tag:深度学习" class="tag" target="_blank" rel="noopener">#深度学习</a> <a href=".?query=tag:项目" class="tag" target="_blank" rel="noopener">#项目</a> 📅 2024-12-1
]]></description><link>项目\cs231n：手撕神经网络-.md\cs231n：手撕神经网络-.md.html</link><guid isPermaLink="false">项目/cs231n：手撕神经网络 .md</guid><pubDate>Sun, 13 Oct 2024 00:53:23 GMT</pubDate></item><item><title><![CDATA[GPT是什么]]></title><description><![CDATA[<a class="tag" href="?query=tag:Transformer" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#Transformer</a> <a class="tag" href="?query=tag:注意力机制" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#注意力机制</a> 
 <br><br>
<br>网址链接 <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea" target="_blank">【官方双语】GPT是什么？直观解释Transformer | 深度学习第5章_哔哩哔哩_bilibili</a>，做视频笔记和总结
<br>应该说是一个“深度学习”系列，然后应该把线性代数再拿回来学学（数学）<br><br><br>0:00&nbsp;-&nbsp;预测，采样，重复：预训练/生成式/Transformer模型 3:03&nbsp;-&nbsp;Transformer&nbsp;的内部结构 6:36&nbsp;-&nbsp;本期总述 7:20&nbsp;-&nbsp;深度学习的大框架 12:27&nbsp;-&nbsp;GPT的第一层：词嵌入为向量(embedding) 18:25&nbsp;-&nbsp;嵌入空间不仅代表词，还能包含上下文信息 20:22&nbsp;-&nbsp;GPT的最后一层：向量解码为词(Unembedding) ==22:22&nbsp;-&nbsp;==带温度的&nbsp;Softmax&nbsp;函数 26:03&nbsp;-&nbsp;下期预告：深入注意力机制<br><a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:04:23.068&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:04:23.068</a><br>
注意力机制就是找到哪些模型会改变句子的含义<br>
<img src="项目\assets\pasted-image-20241011151145.png"><br>
注意力机制--&gt;多层感知模块--&gt;并行向量计算<br><a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:08:22.703&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:08:22.703</a><br>
机器学习的实质，通过参数来拟合和预测<br>
<br>反向传播 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:09:29.599&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:09:29.599</a>
<br>模型参数被称为权重
<br>权重参数模型计算如矩阵<img src="项目\assets\pasted-image-20241011151626.png">
<br>权重是模型的大脑，实在训练中获得的，决定训练的方向
<br>将单词转化为向量，词嵌入 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:13:30.612&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:13:30.612</a>

<br>高纬度的重要性、三维切片 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:14:08.606&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:14:08.606</a>
<br>词嵌入具有高维性


<br>结合上下文信息 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:19:31.784&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:19:31.784</a>，上下文长度限制大模型可以结合的文本量
<br><br><a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV13z421U7cs/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:22:34.329&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV13z421U7cs\" target="_blank">00:22:34.329</a><br>
<img src="项目\assets\pasted-image-20241011153047.png"><br>进行归一化操作，使用e作为底<br>
<img src="项目\assets\pasted-image-20241011153124.png"><br>
就是一个归一化的函数
<br>温度：温度越高，模型越可能选择不可能的词，创造力<br>
一些总结的基本概念：词嵌入、softmax函数、点积<br>
Transformer的核心是注意力机制，自注意力
<br><br>3Blue 有7篇的深度学习系列视频，我觉得预备看是有意义的，因此其他的也是有意义的，了解一些基础概念。<br>
<br>深度学习5-7 <a href=".?query=tag:Transformer" class="tag" target="_blank" rel="noopener">#Transformer</a> <a href=".?query=tag:注意力机制" class="tag" target="_blank" rel="noopener">#注意力机制</a> 📅 2024-10-12 ✅ 2024-10-12<br>
<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0" target="_blank">第6章</a>和<a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?spm_id_from=333.999.0.0" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?spm_id_from=333.999.0.0" target="_blank">第7章</a><br>
全篇链接：<a data-tooltip-position="top" aria-label="https://space.bilibili.com/88461692/search/video?keyword=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" rel="noopener" class="external-link" href="https://space.bilibili.com/88461692/search/video?keyword=%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0" target="_blank">3Blue1Brown的个人空间-3Blue1Brown个人主页-哔哩哔哩视频 (bilibili.com)</a>		
<br><br><br>实际在看视频的时候，我认为看深入的话多半是以截图为主，时间链接普遍用于没有听懂的地方。<br>
<br>查询向量Q <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:07:03.754&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:07:03.754</a>
<br>Key 矩阵注意力机制，可以认为key是在回答查询机制 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:08:14.326&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:08:14.326</a>
<br><img src="项目\assets\pasted-image-20241012154037.png"><br>每列经过softmax后，将经过归一化值填表<br>
<a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:10:30.104&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:10:30.104</a><br><img src="项目\assets\pasted-image-20241012154446.png"><br>
<br>多头预测（multi-head）<a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:11:41.371&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:11:41.371</a>
<br>自注意力机制先将前者输入变成负无穷<img src="项目\assets\pasted-image-20241012154609.png">
<br>防止后方的token影响前面的token
<br>上下文更具有拓展性 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:13:05.703&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:13:05.703</a>
<br><br>
<br>QKV <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:13:44.766&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:13:44.766</a>
<br>加和 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:15:15.000&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:15:15.000</a>，预测一个更加精确的值，加到对应的嵌入向量，进行更新
<br>Value矩阵 <img src="项目\assets\pasted-image-20241012155216.png">
<br>对大矩阵进行低秩分解 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:18:15.915&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:18:15.915</a>
<br><br><a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:20:50.825" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:20:50.825</a><br><img src="项目\assets\pasted-image-20241012155710.png"><br><img src="项目\assets\pasted-image-20241012155757.png"><br><a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:22:01.034" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:22:01.034</a> 模型能学习到根据上下文改变语义的多种方式<br>
<br>Value矩阵拆分 <a data-tooltip-position="top" aria-label="jv://?url=https://www.bilibili.com/video/BV1TZ421j7Ke/?spm_id_from=333.999.0.0&amp;vd_source=c36fc5291894a77d2715bc5972a95dea&amp;time=00:22:26.823&amp;app=jump-video-extension" rel="noopener" class="external-link" href="jv:?url=https:\\www.bilibili.com\video\BV1TZ421j7Ke\" target="_blank">00:22:26.823</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=106.737894#t=01:46.74" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=106.737894#t=01:46.74" target="_blank">01:46</a> 多层感知机的模式
<br><a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=166.388145#t=02:46.39" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=166.388145#t=02:46.39" target="_blank">02:46</a> 注意力机制让向量学习
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt2m58.516s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=178.515565#t=02:58.52" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=178.515565#t=02:58.52" target="_blank">02:58</a> 上下文都能吸收到足够的信息
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt3m42.995s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=222.994788#t=03:42.99" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=222.994788#t=03:42.99" target="_blank">03:42</a> 模型的大部分其实存在于多层感知机
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt4m30.445s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=270.445015#t=04:30.45" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=270.445015#t=04:30.45" target="_blank">04:30</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt4m38.177s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=278.176777#t=04:38.18" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=278.176777#t=04:38.18" target="_blank">04:38</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt6m43.473s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=403.47272#t=06:43.47" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=403.47272#t=06:43.47" target="_blank">06:43</a> MLP的原理，多层感知机
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt11m2.584s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=662.583686#t=11:02.58" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=662.583686#t=11:02.58" target="_blank">11:02</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt11m52.009s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=712.009037#t=11:52.01" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=712.009037#t=11:52.01" target="_blank">11:52</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt13m48.474s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=828.474387#t=13:48.47" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=828.474387#t=13:48.47" target="_blank">13:48</a>  
<br><br><br>
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt16m40.239s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1000.239006#t=16:40.24" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1000.239006#t=16:40.24" target="_blank">16:40</a> MLD/神经网络的总量
<br><br>
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt19m12.5s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1152.499528#t=19:12.50" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1152.499528#t=19:12.50" target="_blank">19:12</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt20m10.258s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1210.257571#t=20:10.26" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1210.257571#t=20:10.26" target="_blank">20:10</a> 
<br><img src="项目\assets\【官方双语】直观解释大语言模型如何储存事实-_-【深度学习第7章】pt21m23.375s.webp"> <a data-tooltip-position="top" aria-label="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1283.374703#t=21:23.37" rel="noopener" class="external-link" href="https://www.bilibili.com/video/BV1aTxMehEjK/?t=1283.374703#t=21:23.37" target="_blank">21:23</a> 稀疏自解码器
<br><br>是对Transformer基本原理的一个介绍，深度学习chap5-7的内容。内容部分基本上没听懂，要学的话仍然要从底层开始学习，而不是看着概念发愁。<br>
至于深度学习1-4的章节，不作为本篇的学习内容上，应该单独拿出作为学习部分。<br>
<br>回顾基本原理，不要求都掌握 📅 2024-10-13
]]></description><link>项目\gpt是什么.html</link><guid isPermaLink="false">项目/GPT是什么.md</guid><pubDate>Sat, 12 Oct 2024 09:04:21 GMT</pubDate><enclosure url="项目\assets\pasted-image-20241011151145.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;项目\assets\pasted-image-20241011151145.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Java学习路线]]></title><description><![CDATA[ 
 ]]></description><link>项目\java学习路线.html</link><guid isPermaLink="false">项目/Java学习路线.md</guid><pubDate>Sun, 13 Oct 2024 00:52:01 GMT</pubDate></item><item><title><![CDATA[Linux小简介]]></title><description><![CDATA[ 
 <br>东西确实比较浅显，最深的也就是Linux的结构了。<br><br><a data-tooltip-position="top" aria-label="https://marker.dotalk.cn/#/?nx=HM29KMK&amp;vs=1" rel="noopener" class="external-link" href="https://marker.dotalk.cn/#/?nx=HM29KMK&amp;vs=1" target="_blank">五彩链接</a><br>
<br>对于初学者学习 Linux ，推荐选择 CentOS，原因如下：
<br>CentOS 免费且开放源代码；
<br>CentOS 基于 RHEL，功能与 RHEL 高度一致，安全稳定、性能优秀。

<br>不能作为一般使用吧，而且centos停止使用了


<br>inode：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。
<br>block：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）
<br>可以看出，Linux/Unix 操作系统使用 inode 区分不同的文件。这样做的好处是，即使文件名被修改或删除，文件的 inode 号码不会改变，从而可以避免一些因文件重命名、移动或删除导致的错误。<br>
<img src="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/11CX13-yfgK_zd5yQkEF-f2N92-sB4_kbG" referrerpolicy="no-referrer">
]]></description><link>项目\linux小简介.html</link><guid isPermaLink="false">项目/Linux小简介.md</guid><pubDate>Fri, 11 Oct 2024 13:17:57 GMT</pubDate><enclosure url="https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/11CX13-yfgK_zd5yQkEF-f2N92-sB4_kbG" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://wucaiimg2.wimg.site/hi/M77KCB/2024/10/11CX13-yfgK_zd5yQkEF-f2N92-sB4_kbG&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[reg和wire的区别]]></title><description><![CDATA[ 
 <br>在Verilog中，wire 和 reg（以及它们的向量形式 wire [N:0] 和 reg [N:0]）是两种不同的数据类型，主要区别在于它们在电路中的行为和用途：<br>
<br>
wire:

<br>用于表示连续赋值的信号线。
<br>用于连接模块之间的信号线或组合逻辑的输出。
<br>不能存储值，必须在每个时钟周期内被赋值。
<br>示例：wire [7:0] data_bus;


<br>
reg:

<br>用于表示可以存储值的变量。
<br>通常用于过程块（如always块）中，可以被赋值和更新。
<br>可以用于描述时序逻辑（如寄存器）。
<br>示例：reg [7:0] register;


<br>总结：<br>
<br>wire用于连续赋值的信号线，不能存储值。
<br>reg 用于可以存储值的变量，通常在过程块中使用。
]]></description><link>项目\reg和wire的区别.html</link><guid isPermaLink="false">项目/reg和wire的区别.md</guid><pubDate>Sat, 12 Oct 2024 13:57:34 GMT</pubDate></item><item><title><![CDATA[softmax函数和大模型的温度]]></title><description><![CDATA[ 
 <br>softmax函数和大模型中的温度参数（temperature）之间存在密切的联系。以下是他们之间的关系：<br><br>Softmax 函数是一种数学函数，经常用于机器学习中的分类问题。它的基本作用是将一组数值（通常是模型对于某个类别的得分或者概率）转换成一组概率分布。具体来说，Softmax 函数对于输出 ( y_i ) 的定义如下：<br>[ y_i = \frac{e^{z_i}}{\sum_j e^{z_j}} ]<br>其中，( z_i ) 是模型对于第 ( i ) 个类别的得分，( e ) 是自然对数的底数。Softmax 函数保证了所有的 ( y_i ) 值都是非负的，并且它们加起来等于1，因此构成一个有效的概率分布。<br><br>在大型语言模型（如 GPT-3 等）中，softmax 函数通常不会直接对外输出，而是通过引入一个温度参数来调整整个概率分布的形式。温度参数 ( T ) 通常是模型训练过程中的一个超参数，它可以对模型的输出概率分布产生以下影响：<br>
<br>当 ( T ) 较低时（接近0），概率分布将会更加集中，即预测结果将更加确定。
<br>当 ( T ) 较高时，概率分布会变得更加分散，即模型更多地选择相对概率较高的候选词，每个候选词被选中的可能性更加接近。
<br><br>温度参数与Softmax函数的关系可以通过以下方式理解：<br>[ P(y_i | T) = \frac{e^{z_i / T}}{\sum_j e^{z_j / T}} ]<br>这里，将原始的Softmax函数中的 ( z_i ) 替换为了 ( z_i / T )。随着温度 ( T ) 的增加，函数中的指数项会减小，这会导致分数更加接近，使得每个输出的可能性更加均匀。<br>因此，温度参数 ( T ) 实际上是控制了Softmax函数平滑程度的机制：<br>
<br>较低的温度 ( T ) 导致输出更加尖锐（集中），模拟了预测的准确性。
<br>较高的温度 ( T ) 导致输出更加平滑（分散），模拟了更多的探索可能性。
<br>在大型模型中调整温度参数可以在生成性的不确定性（更多的多样性）和性能（更准确的预测）之间取得平衡。]]></description><link>项目\softmax函数和大模型的温度.html</link><guid isPermaLink="false">项目/softmax函数和大模型的温度.md</guid><pubDate>Fri, 11 Oct 2024 07:55:50 GMT</pubDate></item><item><title><![CDATA[Tasks的任务汇总]]></title><description><![CDATA[ 
 <br>干活读书灵感今天近日<br>SmartSpec: <a rel="noopener" class="external-link" href="https://arxiv.org/abs/2406.14066" target="_blank">https://arxiv.org/abs/2406.14066</a> 🔼 📅<a class="tasks-edit" title="Edit task" href="about:blank#"></a><a class="tasks-postpone tasks-postpone-short-mode" title="ℹ️ Due tomorrow, on 周一 14日 10月 (right-click for more options)"></a><br>verilog： <a rel="noopener" class="external-link" href="https://hdlbits.01xz.net/wiki/Problem_sets" target="_blank">https://hdlbits.01xz.net/wiki/Problem_sets</a><br><a href=".?query=tag:读书" class="tag" target="_blank" rel="noopener" data-tag-name="#读书">#读书</a> 《人性的弱点》 ⛔ 📅<a class="tasks-edit" title="Edit task" href="about:blank#"></a><a class="tasks-postpone tasks-postpone-short-mode" title="ℹ️ Due tomorrow, on 周一 14日 10月 (right-click for more options)"></a><br>看完《人性的弱点》，这书很短的 <a href=".?query=tag:读书" class="tag" target="_blank" rel="noopener">#读书</a><br>kanban如何嵌入文件和预览 <a href=".?query=tag:灵感" class="tag" target="_blank" rel="noopener" data-tag-name="#灵感">#灵感</a> 📅<a rel="noopener" target="_self" class="internal-link internal-link-short-mode"> 🔗</a><a class="tasks-edit" title="Edit task" href="about:blank#"></a><a class="tasks-postpone tasks-postpone-short-mode" title="ℹ️ Due tomorrow, on 周一 14日 10月 (right-click for more options)"></a><br>试图在页面内实现如Notion的页面创建笔记的语法。如果可以展示就更好了。 <a href=".?query=tag:任务记录" class="tag" target="_blank" rel="noopener">#任务记录</a> <a href=".?query=tag:灵感" class="tag" target="_blank" rel="noopener">#灵感</a><br>SmartSpec: <a rel="noopener" class="external-link" href="https://arxiv.org/abs/2406.14066" target="_blank">https://arxiv.org/abs/2406.14066</a> 🔼 📅 2024-10-13 (<a rel="noopener" target="_self" class="internal-link">2024年10月9日 &gt; 正经活</a>)<a class="tasks-edit" title="Edit task" href="about:blank#"></a><a class="tasks-postpone" title="ℹ️ Due tomorrow, on 周一 14日 10月 (right-click for more options)"></a><br>verilog： <a rel="noopener" class="external-link" href="https://hdlbits.01xz.net/wiki/Problem_sets" target="_blank">https://hdlbits.01xz.net/wiki/Problem_sets</a><br>SmartSpec: <a rel="noopener" class="external-link" href="https://arxiv.org/abs/2406.14066" target="_blank">https://arxiv.org/abs/2406.14066</a> 🔼
    
      
        
        
      
    
  ]]></description><link>项目\tasks的任务汇总.html</link><guid isPermaLink="false">项目/Tasks的任务汇总.md</guid><pubDate>Sat, 12 Oct 2024 06:41:35 GMT</pubDate></item><item><title><![CDATA[鸡械绿洲]]></title><description><![CDATA[ 
 鸡械绿洲是一款结合塔防和肉鸽元素的游戏，资源管理多样，通关体验爽快，制作组持续更新，新增内容丰富。]]></description><link>quail\游戏清单\鸡械绿洲.html</link><guid isPermaLink="false">Quail/游戏清单/鸡械绿洲.md</guid><pubDate>Fri, 04 Oct 2024 11:21:53 GMT</pubDate></item><item><title><![CDATA[空洞骑士]]></title><description><![CDATA[<a class="tag" href="?query=tag:游戏" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#游戏</a> 
 空洞骑士是一款类银河恶魔城的游戏，主线通过Boss挑战和护符增强探索能力，战斗模式类似魂系，回血困难。虽然主线简单，神居挑战提供了持续游玩的动力。我喜欢这款游戏及其背景故事，但市场上缺乏类似作品，需要新的故事、机制和角色。]]></description><link>quail\游戏清单\空洞骑士.html</link><guid isPermaLink="false">Quail/游戏清单/空洞骑士.md</guid><pubDate>Wed, 25 Sep 2024 00:52:15 GMT</pubDate><enclosure url="https://i0.hdslb.com/bfs/archive/e18bb4bafe6d08d03611dea2d56fcc7b75c91bf9.jpg@672w_378h_1c_!web-search-common-cover.avif" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/archive/e18bb4bafe6d08d03611dea2d56fcc7b75c91bf9.jpg@672w_378h_1c_!web-search-common-cover.avif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[泰拉瑞亚（原版）]]></title><description><![CDATA[ 
 回顾我玩泰拉瑞亚的经历，从初中到大学，玩原版和各种mod，逐渐熟悉游戏内容和Boss挑战，尤其是猪鲨和光女的战斗体验，每次游戏都带来新体验。]]></description><link>quail\游戏清单\泰拉瑞亚（原版）.html</link><guid isPermaLink="false">Quail/游戏清单/泰拉瑞亚（原版）.md</guid><pubDate>Thu, 26 Sep 2024 10:08:57 GMT</pubDate></item><item><title><![CDATA[泰拉瑞亚（灾厄）]]></title><description><![CDATA[ 
 ]]></description><link>quail\游戏清单\泰拉瑞亚（灾厄）.html</link><guid isPermaLink="false">Quail/游戏清单/泰拉瑞亚（灾厄）.md</guid><pubDate>Tue, 24 Sep 2024 13:05:06 GMT</pubDate></item><item><title><![CDATA[游戏清单]]></title><description><![CDATA[ 
 <br>没人说个人写东西只能发些生活的、或者技术的，其实也可以发游戏的！特别是玩过单机游戏后，是非常适合写自己的感想的。<br>
这种东西发Quail比较合适，因为是比较水的东西，很多图片资料也可以在网上找，更加注重文字。<br><br><br><a data-tooltip-position="top" aria-label="Quail/游戏清单/泰拉瑞亚（原版）.md" data-href="Quail/游戏清单/泰拉瑞亚（原版）.md" href="quail\游戏清单\泰拉瑞亚（原版）.html" class="internal-link" target="_self" rel="noopener">泰拉瑞亚（原版）</a><br><a data-tooltip-position="top" aria-label="Quail/游戏清单/泰拉瑞亚（灾厄）.md" data-href="Quail/游戏清单/泰拉瑞亚（灾厄）.md" href="quail\游戏清单\泰拉瑞亚（灾厄）.html" class="internal-link" target="_self" rel="noopener">泰拉瑞亚（灾厄）</a><br><a data-tooltip-position="top" aria-label="Quail/游戏清单/空洞骑士.md" data-href="Quail/游戏清单/空洞骑士.md" href="quail\游戏清单\空洞骑士.html" class="internal-link" target="_self" rel="noopener">空洞骑士</a><br><a data-tooltip-position="top" aria-label="Quail/游戏清单/鸡械绿洲.md" data-href="Quail/游戏清单/鸡械绿洲.md" href="quail\游戏清单\鸡械绿洲.html" class="internal-link" target="_self" rel="noopener">鸡械绿洲</a>]]></description><link>quail\游戏清单\游戏清单.html</link><guid isPermaLink="false">Quail/游戏清单/游戏清单.md</guid><pubDate>Thu, 26 Sep 2024 10:13:14 GMT</pubDate></item><item><title><![CDATA[使用alist将云盘映射成为webdav]]></title><description><![CDATA[ 
 使用alist将百度网盘挂载为webdav，先配置alist并启动，访问本地界面，续期令牌以确保有效。]]></description><link>quail\2024年9月3日_使用alist.html</link><guid isPermaLink="false">Quail/2024年9月3日_使用alist.md</guid><pubDate>Sun, 22 Sep 2024 05:02:36 GMT</pubDate><enclosure url="quail\assets\7de22746dc07a6584d9b4eccf26cf63f_md5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;quail\assets\7de22746dc07a6584d9b4eccf26cf63f_md5.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2024年9月5日_LinuxIO栈文档笔记]]></title><description><![CDATA[<a class="tag" href="?query=tag:脏页" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#脏页</a> 
 本文介绍了Linux存储IO栈的相关概念，包括设备层与DMA的直接交互、Page Cache与Buffer Cache的区别、Direct IO和Write back的机制，以及脏页的处理和相关的系统调用。]]></description><link>quail\2024年9月5日_linuxio栈文档笔记.html</link><guid isPermaLink="false">Quail/2024年9月5日_LinuxIO栈文档笔记.md</guid><pubDate>Thu, 05 Sep 2024 07:32:24 GMT</pubDate><enclosure url="https://xiaodongq.github.io/images/linux-io-syscall.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://xiaodongq.github.io/images/linux-io-syscall.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[原理]]></title><description><![CDATA[ 
 <br><br>URL缩短器的原理主要是通过使用更短的、易于记忆的标识符来替代原始的、可能非常长的URL。这不仅有助于提高用户体验，也便于在不同的文本文档、电子邮件或社交媒体上分享链接。主要的实现原理包括：<br>
<br>
唯一标识符的生成：<br>
系统生成一个唯一的数字或者字符串作为原始URL的标识符。这些标识符通常通过哈希函数（如MD5、SHA-1、ZlibF等）对原始URL进行处理后生成，目的是保证生成的标识符具有唯一性并具有一定随机性。

<br>
映射表（数据库、内存或文件系统）：<br>
实际上，每生成一个标识符，系统会在一个数据库、内存或者文件系统中记录原始的URL与生成的标识符之间的映射关系。这叫做映射表或者缓存。

<br>
URL重定向：<br>
通过原始代码或外部前端的请求，当用户输入或点击新的、短格式的URL时，服务器会检查这个标识符，从映射表中查找匹配的原始URL，然后重定向浏览器或其他客户端请求到真实的、原始的URL位置。

<br>
负载均衡和缓存控制：<br>
为了提高服务的效率和反应速度，通常会设置缓存机制，记录一段时间内的热门或常访问链接的映射关系。这样，如果用户多次请求相同的短链，服务器可以直接从缓存中读取对应的原始URL，无需频繁查询数据库，从而减少了数据库负载和响应时间。

<br>
安全和隐私考量：<br>
在实现中考虑了安全性和隐私保护，比如使用HTTPS连接保证数据传输的安全，以及采取措施避免短链被恶意使用。

<br>
可度量性和分析：<br>
URL缩短提供了一种易于扩展的数据接口，使得可以追踪和分析链接的点击率、来源渠道、时间分布等信息，这对于推广、广告策略调整等非常有帮助。

<br>例如，像Bitly、TinyURL和Google提供的短链服务都遵循了上述原理，并有一定的差异和创新。具体的实现细节和效率优化则依赖于具体的技术实现和系统设计。<br>]]></description><link>quail\2024年9月23日_url缩短器的原理.html</link><guid isPermaLink="false">Quail/2024年9月23日_URL缩短器的原理.md</guid><pubDate>Mon, 23 Sep 2024 02:31:56 GMT</pubDate></item><item><title><![CDATA[2024年9月24日_不同库之间的任务分工]]></title><description><![CDATA[<a class="tag" href="?query=tag:灵感" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#灵感</a> 
 目前有三个主库：主仓库（记录日记和项目）、PWA学习库（统一管理的小项目）、Projects库（存放代码项目）。子库根据记录性质或非记录性质分隔，未来库增加遵循此规则，非记录子库可用文本链接存放，以减少索引时间。]]></description><link>quail\2024年9月24日_不同库之间的任务分工.html</link><guid isPermaLink="false">Quail/2024年9月24日_不同库之间的任务分工.md</guid><pubDate>Tue, 24 Sep 2024 08:33:51 GMT</pubDate><enclosure url="quail\assets\pasted-image-20240924162928.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;quail\assets\pasted-image-20240924162928.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2024年9月24日_沁苑宿舍也许用得着推荐]]></title><description><![CDATA[ 
 <br>本文是试图介绍我在大学三年内为了改善寝室环境，或者单纯出于好奇但是结果对自己的校园生活有点好处的物品。<br>垃圾桶  寝室默认没有垃圾，而个人每天产生的大量垃圾单纯用塑料袋装也不好，垃圾桶是必备电动车  校园挺大的，而且东西方向都是坡道，有一个电动车，在不坏的前提下是最划算的。悬挂灯  台灯不能覆盖桌面的范围，因此需要一个从上面照射的光源<img src="https://cbu01.alicdn.com/img/ibank/O1CN01Bx7cOL1jmGiqNuZrm_!!3242164590.220x220.jpg?_=2020" referrerpolicy="no-referrer">，类似这种，不过可以大一些。也可以作为冬天断电情况下，厕所应急使用的灯。洗衣机  其实可以说是标配，特别是在冬天洗衣服冻手的阶段。一个洗衣机是要用3-4年的，因此起码不要买特别差的，同时洗衣机要做好清洁热水壶/开水瓶  尽管也可以频繁的去1楼打水，不过有一个热水壶在冬天还是会方便不少。蚊帐  主要用来寝室遮光花洒  寝室有喷头和一个热水龙头，喷头是固定在上方的，因此可以在热水龙上加装一个花洒。注意，由于水龙头是光滑的，因此先装一个水龙头万能转换器，再购买对应尺寸的花洒。晾衣杆  阳台有2个晾衣服的杆子/绳子，如果寝室4个人晾衣服的需要还是比较大，可以买根晾衣杆在中间下方的位置。不过冬天不容易晾干，挂在低处的衣服就容易发臭，谨慎考虑挂什么衣服上去。闭门器   <img src="https://img.alicdn.com/imgextra/i3/2211186434989/O1CN01njJcDy1mj0odTuWml_!!2211186434989-0-alimamacc.jpg_.webp" referrerpolicy="no-referrer">用于控制寝室到阳台的门的，力不用选最大。效果不错
    
      
        
        
      
    
  <br><br>
<br>安卓端

<br>酷安：软件下载中心
<br>智享校园：用于连接洗澡设备
<br>饿了么/美团：外卖，食堂很容易吃腻
<br>菜鸟：快递
<br>阅读：偶尔看看小说
<br>微信读书：用于看电子书
<br>文件闪传：用于和PC传输电子书而不用QQ或者微信传输


<br>Win端：

<br>chrome/edge/firefox：浏览器
<br>Mumu模拟器：手机端游戏
<br>Github
<br>Obsidian：笔记管理软件

<br>Obsidian中午论坛


<br>Marktext/Typora：markdown语法编辑软件
<br>notepad3：取代原生notepad的文本软件
<br>pixpin：截图、长截图
<br>果核剥壳/小众软件：偶尔能找到好用的软件，算是软件平台
<br>Pdf24Tools：本地的pdf工具箱，很好用
<br>everything：本地搜索工具
<br>utools/powertoys：增强搜索工具，或者聚合快速访问工具


<br>Linux端

<br>snipaste：截图软件
<br>utools：跨平台
<br>Obsidian：跨平台
<br>StrokePlus：手势软件


<br>2024_09_24：以上。]]></description><link>quail\2024年9月24日_沁苑宿舍也许用得着推荐.html</link><guid isPermaLink="false">Quail/2024年9月24日_沁苑宿舍也许用得着推荐.md</guid><pubDate>Fri, 04 Oct 2024 06:27:12 GMT</pubDate><enclosure url="https://cbu01.alicdn.com/img/ibank/O1CN01Bx7cOL1jmGiqNuZrm_!!3242164590.220x220.jpg?_=2020" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://cbu01.alicdn.com/img/ibank/O1CN01Bx7cOL1jmGiqNuZrm_!!3242164590.220x220.jpg?_=2020&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[学术GPT]]></title><description><![CDATA[ 
 2024年9月24日使用学术GPT进行论文解析与翻译，效果良好，尤其在多线程翻译下速度提升显著，测试结果显示直接翻译效果不佳。]]></description><link>quail\2024年9月24日_学术gpt.html</link><guid isPermaLink="false">Quail/2024年9月24日_学术GPT.md</guid><pubDate>Tue, 24 Sep 2024 08:39:22 GMT</pubDate><enclosure url="lib\media\pasted-image-20240924090835.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240924090835.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2024年10月5日_出行]]></title><description><![CDATA[ 
 今天自驾游去了木兰天池和大余湾。爬山时台阶越来越窄，山顶的天湖水干了，下山时抓着扶手，途中开始听见鸟鸣。午饭在长轩岭农家饭店，吃得不错。大余湾的老村子正在晒秋，发现这个650年的村子富裕，时间接近下午四点后回家。]]></description><link>quail\2024年10月5日_出行.html</link><guid isPermaLink="false">Quail/2024年10月5日_出行.md</guid><pubDate>Sat, 05 Oct 2024 15:10:16 GMT</pubDate></item><item><title><![CDATA[记一次github被封]]></title><description><![CDATA[ 
 两年前github账号被封，无法fork仓库。因想学前端而申诉解封。通过2FA验证和手机获取验证码的过程困难，尝试修改网页源码和使用虚拟手机号都未成功。最终注册了一个谷歌账号并更改辅助信息，解决了问题。]]></description><link>quail\记一次github被封.html</link><guid isPermaLink="false">Quail/记一次github被封.md</guid><pubDate>Thu, 10 Oct 2024 09:26:44 GMT</pubDate></item><item><title><![CDATA[Quail]]></title><description><![CDATA[ 
 Quail是一个用于发布个人文章的平台，支持基本的markdown语法，支持本地图床，但建议少用图片和复选框。写完文章后需检查语法，并使用`Generate by AI`生成提交信息，注意避免语法问题。]]></description><link>quail\quail.html</link><guid isPermaLink="false">Quail/Quail.md</guid><pubDate>Tue, 24 Sep 2024 08:38:26 GMT</pubDate></item><item><title><![CDATA[Thunderbird操作学校邮箱日历的可能性]]></title><description><![CDATA[ 
 ]]></description><link>quail\thunderbird操作学校邮箱日历的可能性.html</link><guid isPermaLink="false">Quail/Thunderbird操作学校邮箱日历的可能性.md</guid><pubDate>Tue, 08 Oct 2024 11:18:51 GMT</pubDate></item></channel></rss>